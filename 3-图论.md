# 图论

## Dijkstra

```cpp
const int INF=0x3f3f3f3f;
int n,m;
struct qnode
{
    int v,c;
    qnode(int v,int c):v(v),c(c){}
    friend bool operator<(qnode q1,qnode q2)
    {
        return q1.c>q2.c;          //定义优先级相反，此为小值更优先
    }
};
struct edge
{
    int v,w;
    edge(int v,int w):v(v),w(w){}
};
vector<edge> E[maxn];
int vis[maxn];
int dist[maxn];
inline void add(int u,int v,int w)
{
    E[u].emplace_back(v,w);
    E[v].emplace_back(u,w);        //emplace不适用于poj -_-!
}
void dijkstra(int x)       //起点
{
    //memset(vis,0,sizeof(vis));              //这个地方注意如果test Case大于2e5的话用memset可能会被卡常
   // memset(dist,INF,sizeof(dist));          //必要时用for(int i=1;i<=n;i++)初始化  memset慎用
    for(int i=1;i<=n;i++)
        vis[i]=0,dist[i]=INF;
    priority_queue<qnode> q;
    dist[x]=0;
    q.emplace(x,0);
    while(!q.empty())
    {
        qnode temp=q.top();
        q.pop();
        int point=temp.v;       //选取松弛点
        if(vis[point])
            continue;
        vis[point]=1;f
        for(edge i:E[point])
        {
            int v=i.v,w=i.w;
            if(!vis[v]&&dist[v]>dist[point]+w)   //松弛操作
            {
                dist[v]=dist[point]+w;
                q.emplace(v,dist[v]);
            }
        }
    }
}
```

```cpp
int n,m;
struct Dijkstra
{
    struct qnode
    {
        int v,c;
        qnode(int v,int c):v(v),c(c) {}
        friend bool operator<(qnode q1,qnode q2)
        {
            return q1.c>q2.c;          //定义优先级相反，此为小值更优先
        }
    };
    struct edge
    {
        int v,w;
        edge(int v,int w):v(v),w(w) {}
    };
    vector<edge> E[maxn];
    int vis[maxn];
    int dist[maxn];
    inline void add(int u,int v,int w)
    {
        E[u].push_back(edge(v,w));
        E[v].push_back(edge(u,w));
    }
    void solve(int x)       //起点
    {
        //memset(vis,0,sizeof(vis));              //这个地方注意如果test Case大于2e5的话用memset可能会被卡常
        //memset(dist,INF,sizeof(dist));          //必要时用for(int i=1;i<=n;i++)初始化  memset慎用
        for(int i=1; i<=n; i++)
            vis[i]=0,dist[i]=INF;
        priority_queue<qnode> q;
        dist[x]=0;
        q.push(qnode(x,0));
        while(!q.empty())
        {
            qnode temp=q.top();
            q.pop();
            int point=temp.v;       //选取松弛点
            if(vis[point])
                continue;
            vis[point]=1;
            int len=E[point].size();
            for(int i=0; i<len; i++)
            {
                int v=E[point][i].v,w=E[point][i].w;
                if(!vis[v]&&dist[v]>dist[point]+w)   //松弛操作
                {
                    dist[v]=dist[point]+w;
                    q.push(qnode(v,dist[v]));
                }
            }
        }
    }
    int query(int t)
    {
        return dist[t];
    }
}ans;
```

## 拓扑排序

```cpp
vector<int> g[maxn];
int du[maxn], n, m=0, l[maxn];
bool toposort()
{
    memset(du, 0, sizeof du);
    for(int i = 1; i <= n; ++i)
        for(int j = 0; j < g[i].size(); ++j)
            ++du[g[i][j]];
    int tot = 0;
    priority_queue<int, vector<int>, greater<int> > q;//按字典序最小的排序时
    //queue<int> q;
    for(int i = 1; i <= n; ++i)
        if(!du[i])
            q.push(i);
    while(!q.empty())
    {
        int x = q.top(); q.pop();
        l[tot++] = x;
        for(int j = 0; j < g[x].size(); ++j)
        {
            int t = g[x][j];
            --du[t];
            if(!du[t])q.push(t);
        }
    }
    if(tot == n)return 1;
    else        return 0;
}
```