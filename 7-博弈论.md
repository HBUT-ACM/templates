# 博弈论

## 巴什博弈

有一堆数量为 n 的石子，每个人每次可以取 1~m 颗石子，最先取完的一方胜利。

### 结论

n%(m+1）== 0 则先手必败，反之先手必胜。

## 威佐夫博弈

有两堆石子，两个人轮流从任一堆或同时从两堆中取同样多的石子，规定每次至少取一个，
最后取光者获胜。

### 结论

将两堆物品中较少的一堆数量记作 a，另一个记作 b，a ==(b-a）(sqrt（5.0+1）/2.0)时先手为必败态。

## Nim 博弈

有任意堆石子，两个人轮流从任意一堆中拿走任意颗石子，最后取光者获胜。

### 结论

设 a、b、c、…为每堆石子个数，若 a⊕b⊕c⊕… = 0，则该状态为必败态，反之为必胜态。

## SG 函数

定义 mex（minimal excludant）运算，其为集合运算，即为计算该集合中不存在的最小非负整数。
例如： mex({0,2,3}) = 1; mex({1,2,3,4,5}) = 0;
而 SG[x]含义即为在 x 的状态下有多少个后继状态，对所有后继状态的 SG 值进行 mex 运算，结果即为 SG[x]的值。
多个 SG 游戏的最终结果为每个 SG 函数值的异或和，异或和为 0 即为必败点，反之为必胜点。代码模板：

```cpp
//f[N]:可改变当前状态的方式，N 为方式的种类，f[N]要在 getSG 之前先从小到大排序
//SG[]:0~n 的 SG 函数值
//S[]:为 x 后继状态的集合
//n 为 SG[x]中 x 想要达到的最大值，size 为 f 的大小
//预处理需要占用大量时间，请注意调整 MAXN 以及 N 的大小
int f[N], SG[MAXN], S[N];
void getSG(int n, int size) {
    memset(SG, 0, sizeof(SG));
    //因为 SG[0]始终等于 0，所以 i 从 1 开始
    for (int i = 1; i <= n; i++) {
        //每一次都要将上一状态 的 后继集合 重置
        memset(S, 0, sizeof(S));
        for (int j = 0; f[j] <= i && j < size; j++)
            S[SG[i - f[j]]] = 1;  //将后继状态的 SG 函数值进行标记
        for (int j = 0;; j++)
            if (!S[j]) {  //查询当前后继状态 SG 值中最小的非零值
                SG[i] = j;
                break;
            }
    }
}
```

## 斐波拉契博弈

有一堆个数为 n 的石子，游戏双方轮流取石子，同时有一下规则：
1.先手不能直接把石子全部取完；
2.除了第一次，之后每次取石子的数目只能在 1 到上次取石子数的两倍之间（包括边界）。
无石子可取即为失败。

### 结论

若初始时石子数为斐波拉契数则先手为必败态，反之先手必胜。