# 数学

## 逆元

### 扩展欧几里得算法

```cpp
ll exgcd(ll a, ll b, ll &x, ll &y) {     //ax+by=gcd(a,b)
    if (b == 0) {x = 1, y = 0; return a;}
    ll r = exgcd(b, a % b, x, y), tmp;
    tmp = x; x = y; y = tmp - (a / b) * y;
    return r;
}

int exgcd(int a,int b) //ax+by=gcd(a,b) return x;  非递归写法
{
    int x0=1,y0=0,x1=0,y1=1,x=a,y=b,r=a%b,q=a/b;
    while(r)
    {
        x=x0-q*x1;
        y=y0-q*y1;
        x0=x1,y0=y1;
        x1=x,y1=y;
        a=b;
        b=r;
        r=a%b;
        q=a/b;
    }
    return x;
}

ll inv(ll a, ll b) {
    ll r = exgcd(a, b, x, y);
    while (x < 0) x += b;
    return x;
}
```

# 模素数

```cpp
ll quick(ll a,ll b,ll m)
{
    ll ans=1;
    while(b)
    {
        if(b&1)
        {
            ans=(a*ans)%m;
        }
        a=(a*a)%m;
        b>>=1;
    }
    return ans;
}
inline ll inverse(ll a,ll p){return quick(a,p-2,p);}       //模素数求逆元
```

## 最大公约数

```cpp
inline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
```

## 快速幂

### 十进制
```cpp
//O((logn)^2)十进制快速幂 （需要欧拉降幂，慎用）
ll quick_mod_10(ll a,string b,ll m)                   //当模数为素数时
{
    ll ans=1,res[10],temp=1;;                         //res[]用来存a^0,a^1,a^2,a^3……a^9
    a%=m;
    int len=b.length();
    res[0]=1;
    for(int i=1;i<10;i++)
    {
        res[i]=(res[i-1]*a)%m;                        //预处理一下res[]
    }
    for(int i=len-1;i>=0;i--)
    {
        ans=(ans*quick(res[(int)(b[i]-'0')],temp,m))%m;
        temp=(temp*10)%(mod-1);                       //欧拉降幂
    }
    return ans;
}
```

```cpp
//十进制快速幂
ll quickmod_10(ll a,string b,ll m)
{
    ll ans=1;
    a%=m;
    int len=b.length();
    for(int i=len-1;i>=0;i--)
    {
        ans=(ans*quick(a,(int)(b[i]-'0'),m))%m;
        a=quick(a,10,m);
    }
    return ans;
}
```

### O(1)
```cpp
//快速乘 O(1)
inline ll quick_c(ll a, ll b, ll p)
{
    ll c = a*b-(ll)((long double)a*b/p+0.5)*p;
    return c < 0 ? c+p:c;
}
//快速乘O(logn)
ll quick_c(ll a,ll b,ll m)
{
    ll ans=0;
    while(b)
    {
        if(b&1)
        {
            ans=(ans+a)%m;
        }
        b>>=1;
        a=(a+a)%m;
    }
    return ans;
}
```

## 矩阵
```cpp
//矩阵快速幂
struct Matrix                       //矩阵结构体
{
    int sizen;
    ll m[105][105];
};
namespace Matrix_quick
{
const ll mod=1e9+7;
Matrix multi(Matrix a,Matrix b)           //矩阵乘法
{
    int sizen=a.sizen;
    Matrix c;
    c.sizen=sizen;
    memset(c.m,0,sizeof(c.m));
    for(int i=1; i<=sizen; i++)
        for(int j=1; j<=sizen; j++)
            for(int k=1; k<=sizen; k++)
                c.m[i][j]=(c.m[i][j]+a.m[i][k]*b.m[k][j]+mod)%mod;
    return c;
}
Matrix quickpow(Matrix a,ll b)                   //矩阵二进制快速幂
{
    int sizen=a.sizen;
    Matrix c;
    c.sizen=sizen;
    memset(c.m,0,sizeof(c.m));
    for(int i=1; i<=sizen; i++)                            //初始化为单位矩阵
        c.m[i][i]=1;
    while(b)
    {
        if(b&1)
            c=multi(c,a);                                       //快速幂
        a=multi(a,a);
        b>>=1;
    }
    return c;
}
Matrix qucikpow10(Matrix a,string b)           //矩阵十进制快速幂
{
    int sizen=a.sizen,len=b.length();
    Matrix c;
    c.sizen=sizen;
    memset(c.m,0,sizeof(c.m));
    for(int i=1; i<=sizen; i++)                            //初始化为单位矩阵
        c.m[i][i]=1;
    for(int i=len-1; i>=0; i--)
    {
        c=multi(c,quickpow(a,(int)(b[i]-'0')));
        a=quickpow(a,10);
    }
    return c;
}
}
```

## 展开式

```cpp
struct node {
    int a,b,x;
    node(int a=0,int b=0,int x=0):a(a),b(b),x(x){}
    node operator*(const node n) {
        return node(a*n.a+x*b*n.b,a*n.b+b*n.a,x);
    }
    void print() {
        cout<<a<<'+'<<b<<"sqrt("<<x<<')'<<endl;
    }
};
node quick(node a,int b) {
    node sum=node(1,0,a.x);
    while(b)
    {
        if(b&1)
        {
            sum=sum*a;
        }
        b>>=1;
        a=(a*a);
    }
    return sum;
}
signed main() {
    int a,b,x,n;
    while(cin>>a>>b>>x>>n)
    {
        quick(node(a,b,x),n).print();
    }
    return Accepted;
}
```

## 组合数

### 阶乘逆元

```cpp
int fac[maxn];
int ifac[maxn];
int comb(int a,int b)
{
    return 1LL*fac[a]*ifac[b]%mod*ifac[a-b]%mod;
}

void init(int n)
{
    fac[0]=1;
    for(int i=1;i<=n;i++)
        fac[i]=1LL*fac[i-1]*i%mod;
    ifac[n]=quick(fac[n],mod-2,mod)%mod;
    for(int i=n-1;i>=0;i--)
        ifac[i]=1LL*ifac[i+1]*(i+1)%mod;
}
```

### 取模

```cpp
ll comb(ll a,ll b,ll m)
{
    if(a<b) return 0;
    if(a==b) return 1;
    else b=min(b,a-b);
    ll ans=1,ca=1,cb=1;
    for(int i=0;i<b;i++)
    {
        ca=(ca*(a-i))%m;
        cb=(cb*(b-i))%m;
    }
    ans=(ca*inverse(cb,m))%m;
    return ans;
}
```

### 模数小，数字大，使用Lucas定理

```cpp
ll lucas(ll a,ll b,ll p)//Lucas定理
{
	if(a<b)
		return 0;
    ll ans=1;
    while(a&&b)
    {
        ans=(ans*(comp(a%p,b%p,p)))%p;
        a/=p; b/=p;
    }
    return ans;
}
```

## 二次同余方程

```cpp
int read()
{
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}

int n,p,w;
namespace Quadratic_Congruence_Equation
{
#define random(a,b) (rand()%(b-a+1)+a)
#define int long long
bool flag;             //flag记录是否有解
struct Complex
{
    int x,y;
    Complex (int xx=0,int yy=0)
    {
        x=xx;
        y=yy;
    }
};
Complex operator *(Complex a,Complex b)
{
    return Complex(((a.x*b.x%p+w*a.y%p*b.y%p)%p+p)%p,((a.x*b.y%p+a.y*b.x%p)%p+p)%p);
}
Complex ksm(Complex x,int b)
{
    Complex tmp(1,0);
    while(b)
    {
        if(b&1)tmp=tmp*x;
        b>>=1;
        x=x*x;
    }
    return tmp;
}
int ksm(int x,int b)
{
    int tmp=1;
    while(b)
    {
        if(b&1)tmp=tmp*x%p;
        b>>=1;
        x=x*x%p;
    }
    return tmp;
}
int work(int n)          //求解x^2=n(mod p) 返回一个ans,另一个解为p-ans
{
    if(p==2)return n;
    if(ksm(n,(p-1)/2)+1==p)flag=true;   //勒让德符号判断是否有解
    int a;
    while(233)
    {
        a=random(0,p-1);
        w=((a*a-n)%p+p)%p;
        if(ksm(w,(p-1)/2)+1==p)break;
    }
    Complex res(a,1);
    Complex ans(0,0);
    ans=ksm(res,(p+1)/2);
    return ans.x;
}
#undef random(a,b)
#undef int
}
signed main()
{
    srand((unsigned)time(NULL));   //初始化随机数  调用work求解方程
    //如果是ax^2+bx+c=0(mod p) 左右乘4可以得 (2ax-b)^2=b^2-4c(mod 4p)
    //如果gcd(4,p)==1可以消去4
    p=read();n=read();
    n%=p;
    int ans1=work(n);
    int ans2=p-ans1;
    if(flag){printf("No Solution\n");return 0;}
    if(ans1==ans2)printf("%lld\n",ans1);
    else printf("%lld %lld",min(ans1,ans2),max(ans1,ans2));
    return 0;
}
```

### CSL的板子

```cpp
#include <bits/stdc++.h>
 
typedef long long i64;
typedef unsigned long long u64;
const int MOD = 1000000007;
 
i64 q1, q2, w;
struct P {
    i64 x, y;
};
 
P pmul(const P& a, const P& b, i64 p) {
    P res;
    res.x = (a.x * b.x + a.y * b.y % p * w) % p;
    res.y = (a.x * b.y + a.y * b.x) % p;
    return res;
}
i64 bin(i64 x, i64 n, i64 MOD) {
    i64 ret = MOD != 1;
    for (x %= MOD; n; n >>= 1, x = x * x % MOD)
        if (n & 1) ret = ret * x % MOD;
    return ret;
}
P bin(P x, i64 n, i64 MOD) {
    P ret = {1, 0};
    for (; n; n >>= 1, x = pmul(x, x, MOD))
        if (n & 1) ret = pmul(ret, x, MOD);
    return ret;
}
i64 Legendre(i64 a, i64 p) { return bin(a, (p - 1) >> 1, p); }
std::mt19937_64 g(std::clock());
i64 equation_solve(i64 b, i64 p) {
    if(b == 0) return 0;
    if (p == 2) return 1;
    if ((Legendre(b, p) + 1) % p == 0)
        return -1;
    i64 a;
    while (true) {
        a = g() % p;
        w = ((a * a - b) % p + p) % p;
        if ((Legendre(w, p) + 1) % p == 0)
            break;
    }
    return bin({a, 1}, (p + 1) >> 1, p).x;
}
 
i64 pow64(i64 a, i64 b) {
    if(b <= 0) return 1;
    i64 result = 1;
    do {
        if(b & 1) result = result * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    } while(b);
    return result;
}
i64 inv64(i64 x) { return pow64(x, MOD - 2); }
 
int t;
int b, c;
const i64 INV2 = inv64(2);
 
int main() {
    std::scanf("%d", &t);
    for(int test = 0; test < t; ++test) {
        std::scanf("%d%d", &b, &c);
        i64 d = equation_solve(((i64(b) * b - i64(4) * c) % MOD + MOD) % MOD, MOD);
        if(d < 0) std::puts("-1 -1");
        else {
            i64 x = (b + d) * INV2 % MOD, y = ((b - d) * INV2 % MOD + MOD) % MOD;
            if(x > y) std::swap(x, y);
            if((x + y) % MOD == b && (x * y) % MOD == c) std::printf("%lld %lld\n", x, y);
            else std::puts("-1 -1");
        }
    }
}
```

## 高次同余方程(HDU3930)
### $x^{a}=b(mod)p$

#### BSGS
```cpp
namespace BSGS
{
const int HashMod=100007;
struct HashTable
{
    struct Line
    {
        int u,v,next;
    } e[1000000];
    int h[HashMod],cnt;
    void Add(int u,int v,int w)
    {
        e[++cnt]=(Line)
        {
            w,v,h[u]
        };
        h[u]=cnt;
    }
    void Clear()
    {
        memset(h,0,sizeof(h));
        cnt=0;
    }
    void Hash(int x,int k)
    {
        int s=x%HashMod;
        Add(s,k,x);
    }
    int Query(int x)
    {
        int s=x%HashMod;
        for(int i=h[s]; i; i=e[i].next)
            if(e[i].u==x)return e[i].v;
        return -1;
    }
} Hash;
int fpow(int a,int b,int MOD)
{
    int s=1;
    while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}
    return s;
}
//BSGS(yyb巨佬)
void solve(int y,int z,int p)
{
    if(y%p==0)
    {
        printf("no solution\n");
        return;
    }
    y%=p;
    z%=p;
    if(z==1)
    {
        puts("0");
        return;
    }
    int m=sqrt(p)+1;
    Hash.Clear();
    for(register int i=0,t=z; i<m; ++i,t=1ll*t*y%p)Hash.Hash(t,i);
    for(register int i=1,tt=fpow(y,m,p),t=tt; i<=m+1; ++i,t=1ll*t*tt%p)
    {
        int k=Hash.Query(t);
        if(k==-1)continue;
        printf("%d\n",i*m-k);
        return;
    }
    printf("no solution\n");
}
}
```

#### 扩展BSGS

```cpp
namespace exBSGS
{
const int HashMod=100007;
struct HashTable
{
    struct Line
    {
        int u,v,next;
    } e[1000000];
    int h[HashMod],cnt;
    void Add(int u,int v,int w)
    {
        e[++cnt]=(Line)
        {
            w,v,h[u]
        };
        h[u]=cnt;
    }
    void Clear()
    {
        memset(h,0,sizeof(h));
        cnt=0;
    }
    void Hash(int x,int k)
    {
        int s=x%HashMod;
        Add(s,k,x);
    }
    int Query(int x)
    {
        int s=x%HashMod;
        for(int i=h[s]; i; i=e[i].next)
            if(e[i].u==x)return e[i].v;
        return -1;
    }
} Hash;
int fpow(int a,int b,int MOD)
{
    int s=1;
    while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}
    return s;
}
void NoAnswer(){puts("No Solution");}
//exBSGS(yyb巨佬)
void solve(int y,int z,int p)         //y^x=z(modp) p不一定为素数
{
    if(z==1){puts("0");return;}
    int k=0,a=1;
    while(233)
    {
        int d=__gcd(y,p);if(d==1)break;
        if(z%d){NoAnswer();return;}
        z/=d;p/=d;++k;a=1ll*a*y/d%p;
        if(z==a){printf("%d\n",k);return;}
    }
    Hash.Clear();
    int m=sqrt(p)+1;
    for(int i=0,t=z;i<m;++i,t=1ll*t*y%p)Hash.Hash(t,i);
    for(int i=1,tt=fpow(y,m,p),t=1ll*a*tt%p;i<=m;++i,t=1ll*t*tt%p)
    {
        int B=Hash.Query(t);if(B==-1)continue;
        printf("%d\n",i*m-B+k);return;
    }
    NoAnswer();
}
}
```

```cpp
#include <algorithm>
#include <iostream>
#include <sstream>
#include <utility>
#include <string>
#include <vector>
#include <queue>
#include <map>
#include <set>
#include <cstring>
#include <cstdio>
#include <cmath>
#define met(a,b) memset(a, b, sizeof(a));
#define IN freopen("in.txt", "r", stdin);
#define OT freopen("ot.txt", "w", stdout);
using namespace std;
typedef long long LL;
typedef pair<int, int> PII;
const int maxn = 1e6 + 100;
const LL INF = 0x7fffffff;
const int dir[5][2] = {0,0,-1,0,1,0,0,-1,0,1};
const LL MOD = 1e9+7;
const double eps = 1e-6;

LL a, b, p;

//工具
bool is[maxn]; LL prm[maxn], id;
LL getprm(LL n) {
    if(n == 1) return 0;
    LL k = 0; met(is, 1);
    is[0] = is[1] = 0;
    for(LL i = 2; i < n; ++i) {
        if(is[i]) prm[k++] = i;
        for(LL j = 0; j < k && (i*prm[j] < n); ++j) {
            is[i*prm[j]] = 0;
            if(i % prm[j] == 0) break;
        }
    }
    return k;
}

LL Euler(LL x) {    //素数的欧拉函数
    return x-1;
}

LL gcd(LL a, LL b){
    return b ? gcd(b, a%b) : a;
}
LL extgcd(LL a, LL b, LL& x, LL& y) {
    if (b == 0) { x=1; y=0; return a; }
    LL d = extgcd(b, a % b, x, y);
    LL t = x; x = y; y = t - a / b * y;
    return d;
}

//快速乘 -- a*b % mod
LL pow_mul(LL a, LL b, LL p) {
    LL r = 0; a %= p;
    while(b) {
        if(b&1) r = (r+a) % p;
        a = (a+a) % p;
        b >>= 1;
    }
    return r;
}

LL pow_mod(LL a, LL b, LL p) {
    LL r = 1; a %= p;
    while(b) {
        if(b&1) r = pow_mul(r, a, p);
        a = pow_mul(a, a, p);
        b >>= 1;
    }
    return r;
}

//求原根
LL fac[maxn], num[maxn], tot;
LL Factor(LL n){
    LL ans = 1, temp = n; tot = 0;
    for (LL i = 0; i < id && prm[i] * prm[i] <= temp; i++){
        if (n % prm[i] == 0){
            fac[tot] = prm[i], num[tot] = 0;
            while (n%prm[i] == 0) n /= prm[i], ++num[tot];
            ans *= (num[tot] + 1);
            ++tot;
        }
    }
    if (n != 1){
        fac[tot] = n, num[tot] = 1;
        ans *=(num[tot]+1);
        ++tot;
    }
    return ans;
}

LL root(LL p) {
    LL phi = Euler(p);
    Factor(phi);
    for(LL g = 2; ; g++) {
        bool f = 1;
        for(int i = 0; i < tot; ++i) {
            LL t = phi / fac[i];
            if(pow_mod(g, t, p) == 1) { f = 0; break; }
        }
        if(f) return g;
    }
}

//BSGS
LL BSGS(LL a, LL b, LL p) {
    a %= p; b %= p;
    map<LL, LL> h;
    LL m = ceil(sqrt(p)), x, y, d, t = 1, v = 1;
    for(LL i = 0; i < m; ++i) {
        if(h.count(t)) h[t] = min(h[t], i);
        else h[t] = i;
        t = pow_mul(t, a, p);
    }
    for(LL i = 0; i < m; ++i) {
        d = extgcd(v, p, x, y);
        x = (x* b/d % p + p) % (p);
        if(h.count(x)) return i*m + h[x];
        v = pow_mul(v, t, p);
    }
    return -1;
}

//求模线性方程
LL modeq(LL a, LL b, LL p, LL r[]) {
    LL e, i, d, x, y;
    d = extgcd(a, p, x, y);
    if (b % d) { return -1; }
    e = (x * (b / d) + p) % p;
    for (i = 0; i < d; i++) {
        r[i] = (e + i*(p/d) + p) % p;
    }// 总共 (a, m) 个解
    return d;
}

//开始解决问题
LL solve(LL a, LL b, LL p, LL r[], LL ans[]) {
    LL g = root(p);
    LL t1 = BSGS(g, b, p);
    LL phi = Euler(p);
    LL cnt = modeq(a, t1, phi, r);
    if(cnt == -1) return -1;
    for(int i = 0; i < cnt; ++i) {
        ans[i] = pow_mod(g, r[i], p);
    }
    return cnt;
}

LL ans[maxn], res[maxn];

int main() {
    #ifdef _LOCAL
    IN; //OT;
    #endif // _LOCAL
    id = getprm(maxn-1); LL kase = 0;
    while(scanf("%lld%lld%lld", &a, &p, &b) == 3) {
        LL cnt = solve(a, b, p, res, ans);
        printf("case%lld:\n", ++kase);
        if(cnt == -1) { printf("-1\n"); continue; }
        sort(ans, ans + cnt);
        for(int i = 0; i < cnt; ++i) printf("%lld\n", ans[i]);
    }
    return 0;
}
```

### ZZQ模板

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define MP make_pair
typedef pair<int,int> pii;
typedef long long ll;
typedef double ld;
typedef vector<int> vi;
#define fi first
#define se second
#define fe first
#define FO(x) {freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);}
#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}
#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}
#define es(x,e) (int e=fst[x];e;e=nxt[e])
#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])
#define VIZ {printf("digraph G{\n"); for(int i=1;i<=n;i++) for es(i,e) printf("%d->%d;\n",i,vb[e]); puts("}");}
#define VIZ2 {printf("graph G{\n"); for(int i=1;i<=n;i++) for es(i,e) if(vb[e]>=i)printf("%d--%d;\n",i,vb[e]); puts("}");}
#define SZ 666666
template<class T>
inline T dw();
template<>
inline ll dw<ll>()
{
    return 1;
}
template<>
inline int dw<int>()
{
    return 1;
}
typedef pair<ll,ll> pll;
ll pll_s;
inline pll mul(pll a,pll b,ll p)
{
    pll ans;
    ans.fi=a.fi*b.fi%p+a.se*b.se%p*pll_s%p;
    ans.se=a.fi*b.se%p+a.se*b.fi%p;
    ans.fi%=p;
    ans.se%=p;
    return ans;
}
inline ll mul(ll a,ll b,ll c)
{
    return a*b%c;
}
//a^b mod c
template<class T>
T qp(T a,ll b,ll c)
{
    T ans=dw<T>();
    while(b)
    {
        if(b&1) ans=mul(ans,a,c);
        a=mul(a,a,c);
        b>>=1;
    }
    return ans;
}
inline ll ll_rnd()
{
    ll ans=0;
    for(int i=1; i<=5; i++)
        ans=ans*32768+rand();
    if(ans<0) ans=-ans;
    return ans;
}
//(x,y) -> x+sqrt(pll_s)*y
template<>
inline pll dw<pll>()
{
    return pll(1,0);
}
//find (possibly) one root of x^2 mod p=a
//correctness need to be checked
ll sqr(ll a,ll p)
{
    if(!a) return 0;
    if(p==2) return 1;
    ll w,q;
    while(1)
    {
        w=ll_rnd()%p;
        q=w*w-a;
        q=(q%p+p)%p;
        if(qp(q,(p-1)/2,p)!=1)
            break;
    }
    pll_s=q;
    pll rst=qp(pll(w,1),(p+1)/2,p);
    ll ans=rst.fi;
    ans=(ans%p+p)%p;
    return ans;
}
//solve x^2 mod p=a
vector<ll> all_sqr(ll a,ll p)
{
    vector<ll> vec;
    a=(a%p+p)%p;
    if(!a)
    {
        vec.pb(0);
        return vec;
    }
    ll g=sqr(a,p);
    ll g2=(p-g)%p;
    if(g>g2) swap(g,g2);
    if(g*g%p==a) vec.pb(g);
    if(g2*g2%p==a&&g!=g2) vec.pb(g2);
    return vec;
}
ll s3_a;
//f0+f1*x+f2*x^2 (for x^3=s3_a)
struct s3
{
    ll s[3];
    s3()
    {
        s[0]=s[1]=s[2]=0;
    }
    s3(ll* p)
    {
        s[0]=p[0];
        s[1]=p[1];
        s[2]=p[2];
    }
    s3(ll a,ll b,ll c)
    {
        s[0]=a;
        s[1]=b;
        s[2]=c;
    }
};
template<>
s3 dw<s3>()
{
    return s3(1,0,0);
}
s3 rs3(ll p)
{
    return s3(ll_rnd()%p,ll_rnd()%p,ll_rnd()%p);
}
s3 mul(s3 a,s3 b,ll p)
{
    ll k[3]= {};
    for(int i=0; i<3; i++)
    {
        for(int j=0; j<3; j++)
        {
            if(i+j<3) k[i+j]+=a.s[i]*b.s[j]%p;
            else k[i+j-3]+=a.s[i]*b.s[j]%p*s3_a%p;
        }
    }
    for(int i=0; i<3; i++) k[i]%=p;
    return s3(k[0],k[1],k[2]);
}
//solve x^3 mod p=a
vector<ll> all_cr(ll a,ll p)
{
    vector<ll> vec;
    a=(a%p+p)%p;
    if(!a)
    {
        vec.pb(0);
        return vec;
    }
    if(p<=3)
    {
        for(int i=0; i<p; i++)
        {
            if(i*i*i%p==a) vec.pb(i);
        }
        return vec;
    }
    if(p%3==2)
    {
        vec.pb(qp(a,(p*2-1)/3,p));
        return vec;
    }
    if(qp(a,(p-1)/3,p)!=1) return vec;
    ll l=(sqr(p-3,p)-1)*qp(2LL,p-2,p)%p,x;
    s3_a=a;
    while(1)
    {
        s3 u=rs3(p);
        s3 v=qp(u,(p-1)/3,p);
        if(v.s[1]&&!v.s[0]&&!v.s[2])
        {
            x=qp(v.s[1],p-2,p);
            break;
        }
    }
    x=(x%p+p)%p;
    vec.pb(x);
    vec.pb(x*l%p);
    vec.pb(x*l%p*l%p);
    sort(vec.begin(),vec.end());
    return vec;
}
map<ll,ll> gg;
ll yss[2333];
int yyn=0;
//find x's primitive root
inline ll org_root(ll x)
{
    ll& pos=gg[x];
    if(pos) return pos;
    yyn=0;
    ll xp=x-1;
    for(ll i=2; i*i<=xp; i++)
    {
        if(xp%i) continue;
        yss[++yyn]=i;
        while(xp%i==0) xp/=i;
    }
    if(xp!=1) yss[++yyn]=xp;
    ll ans=1;
    while(1)
    {
        bool ok=1;
        for(int i=1; i<=yyn; i++)
        {
            ll y=yss[i];
            if(qp(ans,(x-1)/y,x)==1)
            {
                ok=0;
                break;
            }
        }
        if(ok) return pos=ans;
        ++ans;
    }
}
map<ll,int> bsgs_mp;
//find smallest x: a^x mod p=b
ll bsgs(ll a,ll b,ll p)
{
    if(b==0) return 1;
    map<ll,int>& ma=bsgs_mp;
    ma.clear();
    //only /2.5 for speed...
    ll hf=sqrt(p)/2.5+2,cur=b;
    for(int i=0; i<hf; i++)
        ma[cur]=i+1, cur=cur*a%p;
    ll qwq=1,qh=qp(a,hf,p);
    for(int i=0;; i++)
    {
        if(i)
        {
            if(ma.count(qwq))
                return i*hf-(ma[qwq]-1);
        }
        qwq=qwq*(ll)qh%p;
    }
    return 1e18;
}
//ax+by=1
void exgcd(ll a,ll b,ll& x,ll& y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    ll p=x-a/b*y;
    x=y;
    y=p;
}
template<class T>
T gcd(T a,T b)
{
    if(b) return gcd(b,a%b);
    return a;
}
//solve x^a mod p=b
vector<ll> kr(ll a,ll b,ll p)
{
    vector<ll> rst;
    if(!b)
    {
        rst.pb(0);
        return rst;
    }
    ll g=org_root(p);
    ll pb=bsgs(g,b,p);
    ll b1=a,b2=p-1,c=pb;
    ll gg=gcd(b1,b2);
    if(c%gg) return rst;
    b1/=gg, b2/=gg, c/=gg;
    ll x1,x2;
    exgcd(b1,b2,x1,x2);
    x1*=c;
    x1=(x1%b2+b2)%b2;
    ll cs=qp(g,x1,p),ec=qp(g,b2,p);
    for(ll cur=x1; cur<p-1; cur+=b2)
        rst.pb(cs), cs=cs*ec%p;
    sort(rst.begin(),rst.end());
    return rst;
}
```

```cpp
#include <algorithm>
#include <iostream>
#include <sstream>
#include <utility>
#include <string>
#include <vector>
#include <queue>
#include <map>
#include <set>
#include <cstring>
#include <cstdio>
#include <cmath>
#define met(a,b) memset(a, b, sizeof(a));
#define IN freopen("in.txt", "r", stdin);
#define OT freopen("ot.txt", "w", stdout);
using namespace std;
typedef long long LL;
typedef pair<int, int> PII;
const int maxn = 1e6 + 100;
const LL INF = 0x7fffffff;
const int dir[5][2] = {0,0,-1,0,1,0,0,-1,0,1};
const LL MOD = 1e9+7;
const double eps = 1e-6;

LL a, b, p;

bool is[maxn]; LL prm[maxn], id;
LL getprm(LL n) {
    if(n == 1) return 0;
    LL k = 0; met(is, 1);
    is[0] = is[1] = 0;
    for(LL i = 2; i < n; ++i) {
        if(is[i]) prm[k++] = i;
        for(LL j = 0; j < k && (i*prm[j] < n); ++j) {
            is[i*prm[j]] = 0;
            if(i % prm[j] == 0) break;
        }
    }
    return k;
}

/*
LL Euler(LL x) {    //素数的欧拉函数
    return x-1;
}*/

LL Euler(LL x) {
    LL ans = x, m = (LL)sqrt(x*1.0)+1;
    for(LL i = 2; i < m; ++i) if(x%i == 0) {
        ans = ans / i * (i-1);
        while(x%i == 0) x /= i;
    }
    if(x > 1) ans = ans / x * (x-1);
    return ans;
}

LL gcd(LL a, LL b){
    return b ? gcd(b, a%b) : a;
}
LL extgcd(LL a, LL b, LL& x, LL& y) {
    if (b == 0) { x=1; y=0; return a; }
    LL d = extgcd(b, a % b, x, y);
    LL t = x; x = y; y = t - a / b * y;
    return d;
}

//快速乘 -- a*b % mod
LL pow_mul(LL a, LL b, LL p) {
    LL r = 0; a %= p;
    while(b) {
        if(b&1) r = (r+a) % p;
        a = (a+a) % p;
        b >>= 1;
    }
    return r;
}

LL pow_mod(LL a, LL b, LL p) {
    LL r = 1; a %= p;
    while(b) {
        if(b&1) r = pow_mul(r, a, p);
        a = pow_mul(a, a, p);
        b >>= 1;
    }
    return r;
}


LL Factor(LL n, LL fac[], LL num[], LL& tot){
    LL ans = 1, temp = n; tot = 0;
    for (LL i = 0; i < id && prm[i] * prm[i] <= temp; i++){
        if (n % prm[i] == 0){
            fac[tot] = prm[i], num[tot] = 0;
            while (n%prm[i] == 0) n /= prm[i], ++num[tot];
            ans *= (num[tot] + 1);
            ++tot;
        }
    }
    if (n != 1){
        fac[tot] = n, num[tot] = 1;
        ans *=(num[tot]+1);    //n的素因数中最多只有一个大于根号n的;
        ++tot;
    }
    return ans;
}

LL fac[maxn], num[maxn];
LL root(LL p, LL phi) {
    //LL phi = Euler(p);
    LL tot;
    Factor(phi, fac, num, tot);
    for(LL g = 2; ; g++) {
        bool f = 1;
        for(int i = 0; i < tot; ++i) {
            LL t = phi / fac[i];
            if(pow_mod(g, t, p) == 1) { f = 0; break; }
        }
        if(f && pow_mod(g, phi, p) == 1) return g;
    }
    return -1;
}

LL modeq(LL a, LL b, LL p, LL r[]) {
    LL e, i, d, x, y;
    d = extgcd(a, p, x, y);
    if (b % d) { return -1; }
    e = (x * (b / d) + p) % p;
    for (i = 0; i < d; i++) {
        r[i] = (e + i*(p/d) + p) % p;
    }// 总共 (a, m) 个解
    return d;
}

LL CRT(LL a[], LL m[], LL k) {
    LL i, d, x, y, Mi, ans = 0, M = 1;
    for (i = 0; i < k; i++) M *= m[i];  // !  注意不能overflow
    for (i = 0; i < k; i++) {
        Mi = M / m[i];
        d = extgcd(m[i], Mi, x, y);     // y 为逆元 -- Mi*y === 1 (% m[i])
        ans = (ans + a[i]*y*Mi) % M;
    }
    if (ans >= 0) return ans;
    else return (ans + M);
}

LL exBSGS(LL a, LL b, LL p) {
    a = (a%p+p)%p; b = (b%p+p)%p;
    LL ret = 1;
    for(LL i = 0; i <= 50; ++i) {
        if(ret == b) return i;
        ret = (ret*a) % p;
    }//枚举比较小的i

    LL x,y,d, v = 1, cnt = 0;
    while((d = gcd(a, p)) != 1) {
        if(b % d) return -1;
        b /= d, p /= d;
        v = (v * (a/d)) % p;
        ++cnt;
    }//约分直到(a, p) == 1

    map<LL, LL> h;
    LL m = ceil(sqrt(p)), t = 1;
    for(LL i = 0; i < m; ++i) {
        if(h.count(t)) h[t] = min(h[t], i);
        else h[t] = i;
        t = (t*a) % p;
    }
    for(LL i = 0; i < m; ++i) {
        d = extgcd(v, p, x, y);
        x = (x* (b/d) % p + p) % p;
        if(h.count(x)) return i*m + h[x] + cnt;
        v = (v*t) % p;
    }
    return -1;
}


LL F[maxn], N[maxn], P[maxn], E[maxn], r[maxn], tot;
vector< vector<LL> > ans;
vector<LL> ot;

LL A[maxn], M[maxn];
void dfs(LL dep, LL N){
    if( dep == N ){ ot.push_back(CRT(A, M, N)); }
    else {
        for(LL i = 0; i < ans[dep].size(); ++i) {
            A[dep] = ans[dep][i];
            dfs(dep+1, N);
        }
    }
}

LL solve(LL a, LL b, LL p, LL r[]) {
    //分解因式
    Factor(p, F, N, tot);
    for(LL i = 0; i < tot; ++i) {
        P[i] = pow_mod(F[i], N[i], p*2);
        E[i] = P[i] - P[i]/F[i];
    }

    ans.clear();
    for(LL i = 0; i < tot; ++i) {
        vector<LL> res;
        if(F[i] == 2) {
            LL tb = (b%P[i]+P[i])%P[i];
            for(LL j = 0; j < P[i]; ++j) {
                if(pow_mod(j, a, P[i]) == tb) res.push_back(j);
            }
            if(res.size() == 0) return -1;
            sort(res.begin(), res.end());
            res.erase(unique(res.begin(), res.end()), res.end());
            ans.push_back(res);
            continue;
        }
        if(b % P[i] == 0) {
            LL x = 0, ret = 1;
            while(pow_mod(ret, a, P[i]) != 0) ret *= F[i];
            for(int j = 0; j < P[i]/ret; ++j) res.push_back(ret*j);
            sort(res.begin(), res.end());
            res.erase(unique(res.begin(), res.end()), res.end());
            ans.push_back(res);
            continue;
        }

        LL tp = P[i], tb = b%tp,te = E[i];//, d = gcd(tp, tb);
        LL g = root(tp, te);        if(g == -1) return -1;  //求原根
        LL t1 = exBSGS(g, tb, tp);     if(t1 == -1) return -1; //求离散对数
        LL cnt = modeq(a, t1, te, r); if(cnt == -1) return -1;//求log_gX
        for(LL j = 0; j < cnt; ++j) {
            res.push_back(pow_mod(g, r[j], tp));
        }
        sort(res.begin(), res.end());
        res.erase(unique(res.begin(), res.end()), res.end());
        ans.push_back(res);
    }

    //CRT合并
    ot.clear();
    for(LL i = 0; i < tot; ++i) M[i] = P[i];
    dfs(0, tot);
    sort(ot.begin(), ot.end());
    ot.erase(unique(ot.begin(), ot.end()), ot.end());

}

int main() {
    #ifdef _LOCAL
    IN; //OT;
    #endif // _LOCAL

    id = getprm(maxn-1);
    int t; cin >> t;
    while(t--) {
        scanf("%lld%lld%lld", &a, &p, &b);
        if(solve(a, b, p, r) == -1) printf("No Solution\n");
        else {
            for(LL i = 0; i < ot.size(); ++i) printf("%lld ", ot[i]);
            printf("\n");
        }
    }
    return 0;
}
```

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=201010;
unordered_map<int,int> hsh;
int prime[N],tot,T,phi,ans[N],num,a,b,p,g,x,y;
int read()
{
    int sum=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        sum=sum*10+ch-'0';
        ch=getchar();
    }
    return sum*f;
}
void work(int x)
{
    int tmp=x;
    tot=0;
    for(int i=2; i*i<=x; i++)
    {
        if(tmp%i==0)
        {
            prime[++tot]=i;
            while(tmp%i==0)tmp/=i;
        }
    }
    if(tmp>1)prime[++tot]=tmp;
}
int ksm(int x,int b)
{
    int tmp=1;
    while(b)
    {
        if(b&1)tmp=tmp*x%p;
        b>>=1;
        x=x*x%p;
    }
    return tmp;
}
int BSGS(int a,int b)
{
    hsh.clear();
    int block=sqrt(p)+1;
    int tmp=b;
    for(int i=0; i<block; i++,tmp=tmp*a%p)hsh[tmp]=i;
    a=ksm(a,block);
    tmp=1;
    for(int i=0; i<=block; i++,tmp=tmp*a%p)
    {
        if(hsh.count(tmp)&&i*block-hsh[tmp]>=0)return i*block-hsh[tmp];
    }
}
int exgcd(int &x,int &y,int a,int b)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    int gcd=exgcd(x,y,b,a%b);
    int z=x;
    x=y;
    y=z-(a/b)*y;
    return gcd;
}
void solve(int a,int b,int p)      //求x^a=b(mod p)的所有解
{
    b%=p;
    phi=p-1;
    work(phi);
    for(int i=1; i<=p; i++)
    {
        bool flag=false;
        for(int j=1; j<=tot; j++)
        {
            if(ksm(i,phi/prime[j])==1)
            {
                flag=true;
                break;
            }
        }
        if(flag==false)
        {
            g=i;
            break;
        }
    }
    int r=BSGS(g,b);
    int gcd=exgcd(x,y,a,phi);
    if(r%gcd!=0)
    {
        printf("No Solution\n");
        return;
    }
    x=x*r/gcd;
    int k=phi/gcd;
    x=(x%k+k)%k;
    num=0;
    while(x<phi)
    {
        ans[++num]=ksm(g,x),x+=k;
    }
    sort(ans+1,ans+1+num);
    for(int i=1; i<=num; i++)
        printf("%lld ",ans[i]);
    printf("\n");
}
signed main()
{
    T=read();
    while(T--)
    {
        p=read(),a=read(),b=read();
        solve(a,b,p);
    }
    return 0;
}
```

### $y^{x}=z(mod)p$

```cpp
void BSGS(int y,int z,int p)     //令x=am-b   其中m=sqrt(p)时复杂度最优
{
    //y^(am)=z*y^b(modp)
    if(y%p==0)                 //特判gcd(y,p)!=1时的情况
    {
        cout<<"Orz, I cannot find x!"<<endl;
        return ;
    }
    y%=p,z%=p;
    if(z==1)
    {
        cout<<0<<endl;
        return;
    }
    map<ll,ll> mp;                 //用来存z*y^b(modp)的值 也可以自己写hash
    mp.clear();
    int m=sqrt(p)+1;
    ll temp=quick(y,m,p),b=z;
    for(int i=0; i<m; i++,b=b*y%p)           //存z*y^b(modp)
    {
        mp[b]=i;
    }
    ll sum=temp;
    for(int a=1; (a-1)*(m)<=p; a++)   //用来验证左式是否存在和右式相等的值
    {
        if(mp.count(sum))
        {
            ll ans=a*m-mp[sum];
            cout<<ans<<endl;
            return;
        }
        sum=(sum*temp)%p;
    }
    cout<<"Orz, I cannot find x!"<<endl;
}
```

## 筛法

### 线性筛

```cpp
int vis[maxn],prime[maxn],tol;
void liner_shai()
{
    memset(vis,0,sizeof(vis));
    for(int i=2;i<maxn;i++)
    {
        if(!vis[i])
            prime[tol++]=i;
        for(int j=0;j<tol&&i*prime[j]<maxn;j++)
        {
            vis[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                break;
            }
        }
    }
}
```

```cpp
bool is_prime[maxn + 5];
int prime[maxn + 5], cnt;
ll sp[maxn + 5];
void init(int n) {
    for (int i = 2; i <= n; ++i)is_prime[i] = true;
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            ++cnt;
            prime[cnt] = sp[cnt] = i;
        }
        for (int j = 1; j <= cnt && i * prime[j] <= n; ++j) {
            is_prime[i * prime[j]] = false;
            if (i % prime[j] == 0)break;
        }
    }
    for (int i = 1; i <= cnt; ++i)sp[i] = (sp[i] + sp[i - 1]) % mod;
}
```

### 非线性筛

#### 杜教筛

```cpp
struct djs
{
    bool vis[maxn];
    int prime[maxn],mu[maxn];
    ll f[maxn];
    unordered_map<ll,ll> Hash;         //保存f的前缀和在n/1....n/n 大约2sqrt(n)个点的值
    void init(int n)
    {
        memset(vis,0,sizeof(vis));
        int cnt=0;
        mu[1]=1;
        for(int i=2;i<=n;i++)
        {
            if(!vis[i])
            {
                prime[cnt++]=i;
                mu[i]=-1;
            }
            for(int j=0;j<cnt&&i*prime[j]<=n;j++)
            {
                vis[i*prime[j]]=1;
                if(i%prime[j]==0)
                {
                    break;
                }
                else
                {
                    mu[i*prime[j]]=-mu[i];
                }
            }
        }
        for(ll i=1;i<=n;i++)
        {
            ll g=(i*i-3*i+2)%mod;
            for(ll j=i;j<=n;j+=i)
            {
                f[j]=(f[j]+mu[j/i]*g)%mod;
            }
        }
        for(int i=1;i<=n;i++)                    //注意这个地方求前缀和的时候去掉负数的情况
            f[i]=(f[i]+f[i-1]+mod)%mod;          //或者在最后Query ans的时候判断ans的正负
    }                                            //如果为负则加上mod
    djs()
    {
        init(maxn-5);
        Hash.clear();
    }
    ll get_f(ll n)          //g[1]S[n]=(sum{i=1}^{n} h[i])-(sum{d=2}^{n} g[d]*S[n/d])
    {                       //S[n]为f[i]的前缀和   且必须 h=f*g (*为狄利克雷卷积符号)
        if (n <= maxn - 5) return f[n];
        ll temp=Hash[n];
        if(temp)return temp;
        ll ans =n*(n-1)%mod*(n-2)%mod*inv%mod;        //预处理 h[1]+h[2]+...+h[n] h的前缀和
        for(int l=2,r; l<=n; l=r+1)                   //整除分块
        {
            r=n/(n/l);
            ans=(ans-(r-l+1)*get_f(n/l)%mod)%mod;     //ans-=(g[r]-g[l-1])*S[x/p],所以g[i]的前缀和必须预处理出来
        }
        if(ans<0)
            ans+=mod;
        return Hash[n]=ans;
    }
}D;
```

#### Hash版本

```cpp
struct djs
{
    bool vis[maxn];
    int prime[maxn],mu[maxn];
    ll f[maxn];
    struct HashTable
    {
        struct Line{int u,v,next;}e[1000000];
        int h[HashMod],cnt;
        void Hash(int u,int v,int w){e[++cnt]=(Line){w,v,h[u]};h[u]=cnt;}
        void Clear(){memset(h,0,sizeof(h));cnt=0;}
        void Add(int x,int k)
        {
            int s=x%HashMod;
            Hash(s,k,x);
        }
        int Query(int x)
        {
            int s=x%HashMod;
            for(int i=h[s];i;i=e[i].next)
                if(e[i].u==x)return e[i].v;
            return -1;
        }
    }Hash;
    void init(int n)
    {
        memset(vis,0,sizeof(vis));
        int cnt=0;
        mu[1]=1;
        for(int i=2;i<=n;i++)
        {
            if(!vis[i])
            {
                prime[cnt++]=i;
                mu[i]=-1;
            }
            for(int j=0;j<cnt&&i*prime[j]<=n;j++)
            {
                vis[i*prime[j]]=1;
                if(i%prime[j]==0)
                {
                    break;
                }
                else
                {
                    mu[i*prime[j]]=-mu[i];
                }
            }
        }
        for(ll i=1;i<=n;i++)
        {
            ll g=(i*i-3*i+2)%mod;
            for(ll j=i;j<=n;j+=i)
            {
                f[j]=(f[j]+mu[j/i]*g)%mod;
            }
        }
        for(int i=1;i<=n;i++)
            f[i]=(f[i]+f[i-1]+mod)%mod;            //注意这个地方求前缀和的时候去掉负数的情况
    }                                             //或者在最后Query ans的时候判断ans的正负
    djs()                                           //如果为负则加上mod
    {
        init(maxn-5);
        Hash.Clear();
    }
    ll get_f(ll n)
    {
        if (n <= maxn - 5) return f[n];
        ll temp=Hash.Query(n);
        if(temp!=-1)return temp;
        ll ans =n*(n-1)%mod*(n-2)%mod*inv%mod;
        for(int l=2,r; l<=n; l=r+1)
        {
            r=n/(n/l);
            ans=(ans-(r-l+1)*get_f(n/l)%mod)%mod;
        }
        if(ans<0)
            ans+=mod;
        Hash.Add(n,ans);
        return ans;
    }
}D;
```

#### 非hash

```cpp
struct djs
{
    #define G 100010
    const int inv=inverse(3,mod);
    ll id1[G],id2[G],n;
    int mu[maxn];
    int vis[maxn];
    int prime[maxn];
    ll f[maxn];
    void init(int n)
    {
        int cnt=0;
        mu[1]=1;
        for(int i=2;i<=n;i++)
        {
            if(!vis[i])
            {
                prime[cnt++]=i;
                mu[i]=-1;
            }
            for(int j=0;j<cnt&&i*prime[j]<=n;j++)
            {
                vis[i*prime[j]]=1;
                if(i%prime[j]==0)
                {
                    break;
                }
                else
                {
                    mu[i*prime[j]]=-mu[i];
                }
            }
        }
        for(ll i=1;i<=n;i++)
        {
            ll g=(i*i-3*i+2)%mod;
            for(ll j=i;j<=n;j+=i)
            {
                f[j]=(f[j]+mu[j/i]*g)%mod;
            }
        }
        for(int i=1;i<=n;i++)
        {
            f[i]=(f[i]+f[i-1]+mod)%mod;              //注意在线性筛部分保持非负
        }
    }
    djs()
    {
        init(maxn-5);
        memset(id1,0,sizeof(id1));
        memset(id2,0,sizeof(id2));
    }
    ll id(ll x)                  //获取该块处的前缀和的值
    {
        if(x<G) return id1[x];
        return id2[n/x];
    }
    ll get_f(ll x)          //g[1]S[n]=(sum{i=1}^{n} h[i])-(sum{d=2}^{n} g[d]*S[n/d])
    {                       //S[n]为f[i]的前缀和   且必须 h=f*g (*为狄利克雷卷积符号)
        if(x<=maxn-5) return f[x];
        ll temp=id(x);
        if(temp!=id2[0]) return temp;
        ll ans=x*(x-1)%mod*(x-2)%mod*inv%mod;       //h[1]+h[2]+...+h[n] h的前缀和
        for(ll l=2,r; l<=x; l=r+1)                  //整除分块
        {
            r=x/(x/l);
            ans=(ans-(r-l+1)*get_f(x/l)%mod)%mod;       //ans-=(g[r]-g[l-1])*S[x/p],所以g[i]的前缀和必须预处理出来
        }
        if(ans<0)
            ans+=mod;
        if(x<G)
            return id1[x]=ans;
        else
            return id2[n/x]=ans;
    }
    ll query(ll x)
    {
        if(x<=maxn-5)
            return f[x];
        memset(id1,-1,sizeof(id1));
        memset(id2,-1,sizeof(id2));
        n=x;
        return get_f(x);
    }
    #undef G
}D;
```

### min_25筛

```cpp
int m, id1[maxn + 5], id2[maxn + 5];
ll g1[2 * maxn + 5], g2[2 * maxn + 5], v[2 * maxn + 5], block;
ll n, inv;
void min25() {
    block = sqrt(n);
    init(block);
    for (ll l = 1, r; l <= n; l = r + 1) {
        r = n / (n / l);
        v[++m] = n / l;
        g1[m] = v[m] % mod - 1, g2[m] = (v[m] + 1) % mod * (v[m] % mod) % mod * inv % mod - 1;
        if (v[m] <= block)id1[v[m]] = m;
        else id2[n / v[m]] = m;
    }
    for (int i = 1; i <= cnt; ++i) {
        for (int j = 1; j <= m && 1ll * prime[i] * prime[i] <= v[j]; ++j) {
            int id = (v[j] / prime[i] <= block) ? id1[v[j] / prime[i]] : id2[n / (v[j] / prime[i])];
            g1[j] -= (g1[id] - i + 1) % mod;
            g1[j] %= mod;
            g2[j] -= (sp[i] - sp[i - 1]) * (g2[id] - sp[i - 1]) % mod;
            g2[j] %= mod;
        }
    }
}

ll solve(ll n) {
    ll res = 0;
    for (ll l = 1, r; l <= n; l = r + 1) {
        r = n / (n / l);
        int idr = ((r <= block) ? id1[r] : id2[n / r]), idl = (((l - 1) <= block) ? id1[l - 1] : id2[n / (l - 1)]);
        res += (n / l) % mod * ((n + 1) % mod) % mod * ((g1[idr] - g1[idl]) % mod) % mod;
        res -= (n / l) % mod * ((n / l + 1) % mod) % mod * inv % mod * ((g2[idr] - g2[idl]) % mod) % mod;
        res %= mod;
    }
    for (int i = 1; i <= cnt; ++i) {
        ll v = 1ll * prime[i] * prime[i];
        for (; v <= n; v = v * prime[i]) {
            res += (n + 1) % mod * ((n / v) % mod) % mod;
            res -= (n / v) % mod * ((n / v + 1) % mod) % mod * inv % mod * (v % mod) % mod;
            res %= mod;
        }
    }
    if (res < 0)res += mod;
    return res;
}
```

```cpp
struct Min_25
{
    ll n,Sqr,w[maxn];
    ll prime[maxn],id1[maxn],id2[maxn],h[maxn],g[maxn],m;
    bool vis[maxn];
    int tot,sp[maxn],sp2[maxn];
    void pre(int n)         //预处理出质数
    {                       //举例f=p^2-p
    	tot=0;              //则需要筛出p和p^2的素数处的前缀和
        memset(vis,0,sizeof(vis));   
        vis[1]=true;
        for(int i=2; i<=n; i++)
        {
            if(!vis[i])
                prime[++tot]=i,sp[tot]=(sp[tot-1]+i)%mod,sp2[tot]=(sp2[tot-1]+1ll*i*i%mod)%mod;       //sp为质数的前缀和 ,sp2为素数平方处的前缀和
            for(int j=1; j<=tot&&i*prime[j]<=n; j++)
            {
                vis[i*prime[j]]=true;
                if(i%prime[j]==0)
                    break;
            }
        }
    }
    void init(ll n)
    {
    	m=0;
        for(ll l=1,r; l<=n; l=r+1)
        {
            r=n/(n/l);
            w[++m]=n/l;
            //积性函数f(p)由几个多项式生成就需要几个预处理的函数
            //比如f(p)=p^3-p^2+p-1就需要预处理i^3 i^2 i 1这四个前缀和
            //此处h需要维护素数个数的前缀和，初始化为所有数的前缀和
            h[m]=(w[m]%mod)*((w[m]+1)%mod)%mod*inverse(2,mod)%mod;
            //举例f=p^2-p     h处理2,3,..n的和,g处理2^2,3^2,...n^2的前缀和
            h[m]--;
            //（把所有数都当做质数初始化）           h(x)=f1(2)+f1(3)+...+f1(n)
            g[m]=((w[m]%mod)*((w[m]+1)%mod)%mod)%mod*((2*w[m]+1)%mod)%mod*inverse(6,mod)%mod;
            g[m]--;
            //此处g维护f(p)的前缀和  还是将所有数当做质数
            //（因此初始化为所有数的前缀和）               g(x)=f2(2)+...+f2(x)

            if(w[m]<=Sqr)id1[w[m]]=m;         //用来存小于sqrt(n)整除分块的序号 w[m]<sqrt(n)
            else id2[r]=m;                   //用来存w[n/m] 减少数组内存为sqrt(n)数量级
        }
        //我们需要求出每个g(n/i,|P|)的值，因为在递归求S中只需要这些位置的值

        //接下来利用g(n/l,0)来递推g(n/l,|P|);
        for(int j=1; j<=tot; j++)
        {
            for(int i=1; i<=m&&prime[j]*prime[j]<=w[i]; i++)
            {
                int k=(w[i]/prime[j]<=Sqr)?id1[w[i]/prime[j]]:id2[n/(w[i]/prime[j])];
                //找到k在哪个块 即[n/(l*prime[i])]被存在哪个g/h里面
                g[i]=(g[i]-1ll*(prime[j]*prime[j]%mod)*((g[k]-sp2[j-1])%mod)%mod)%mod;
                //g(n,j)=g(n,j-1)-f(p_j)(g(n/p_j,j-1)-sum{i=1}^{j-1}(f(pi)))
                //此处分别f=p^2,f=p;
                h[i]=(h[i]-1ll*prime[j]*(h[k]-sp[j-1])%mod)%mod;
            }
        }
    }
    ll S(ll x,int y)
    {//S(n,j)=g(n,|P|)-\sum{i=1}^{j-1}(f(i))+\sum{k>j&&p_k^(e+1)<=n}^{}(f(p_k^e)*S(n/(p_k^e),k+1)+f(p_k^(e+1)))
        if(x<=1||prime[y]>x)return 0;
        ll k=(x<=Sqr)?id1[x]:id2[n/x],ret=((g[k]-h[k])%mod-((sp2[y-1]-sp[y-1])%mod))%mod;
                                     //初始化g(x,|P|)-\sum{i=1}^{y-1}(f(i))
        for(int i=y; i<=tot&&1ll*prime[i]*prime[i]<=x; ++i)
        {
            ll t1=prime[i],t2=1ll*prime[i]*prime[i];
            //t1->p^e  t2->p^(e+1)
            for(int e=1; t2<=x; ++e,t1=t2,t2*=prime[i])
            {
                ret=(ret+((1ll*S(x/t1,i+1)*((t1%mod)*((t1-1)%mod)%mod)%mod+((t2%mod)*((t2-1)%mod)%mod)%mod)))%mod;
                //(f(p_k^e)*S(n/(p_k^e),k+1)+f(p_k^(e+1)))
            }
        }
        return ret;
    }
    ll query(ll nn)
    {
        n=nn;
        memset(id1,0,sizeof(id1));
        memset(id2,0,sizeof(id2));
        Sqr=sqrt(nn);
        pre(Sqr);
        init(nn);
        ll ans=S(nn,1)+1;         //最后加上f(1)
        if(ans<0)
            ans+=mod;
        return ans;
    }
}M;
```

### 莫比乌斯函数

```cpp
int mu[maxn];
int vis[maxn];
int prim[maxn];
void get_mu(int n)
{
    int cnt=0;
    mu[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!vis[i])
        {
            prim[cnt++]=i;
            mu[i]=-1;
        }
        for(int j=0;j<cnt&&i*prim[j]<=n;j++)
        {
            vis[i*prim[j]]=1;
            if(i%prim[j]==0)
            {
                break;
            }
            else
            {
                mu[i*prim[j]]=-mu[i];
            }
        }
    }
}
```

### 欧拉函数

```cpp
ll Euler(ll x)
{
    ll ans = x, m = (ll)sqrt(x*1.0)+1;
    for(int i = 2; i < m; ++i)
    {
        if(x%i == 0)
        {
            ans = ans / i * (i-1);
            while(x%i == 0) x /= i;
        }
    }
    if(x > 1) ans = ans / x * (x-1);
    return ans;
}
```

```cpp
int vis[maxn],prime[maxn],tol;
ll phi[maxn];
void get_phi(int n)
{
    memset(vis,0,sizeof(vis));
    phi[1]=1;
    for(int i=2; i<=n; i++)
    {
        if(!vis[i])
        {
            prime[tol++]=i;
            phi[i]=(i-1);
        }
        for(int j=0; j<tol&&i*prime[j]<=n; j++)
        {
            vis[i*prime[j]]=1;
            if(i%prime[j]==0)
            {
                phi[i*prime[j]]=prime[j]*phi[i];
                break;
            }
            else
            {
                phi[i*prime[j]]=phi[i]*(prime[j]-1);
            }
        }
    }
}
```

## 素数分解

```cpp
int num[2][maxn],cnt;
void fenjie_num(ll x)//唯一标准分解
{
    cnt=0;
    for(int i=0; i<tol&&prime[i]<=x/prime[i]; i++)
    {
        if(x%prime[i]==0)
        {
            int temp=0;
            while(x%prime[i]==0)
            {
                x/=prime[i];
                temp++;
            }
            num[0][cnt]=prime[i];
            num[1][cnt++]=temp;
        }
    }
    if(x!=1)
    {
        num[0][cnt]=x;
        num[1][cnt++]=1;
    }
}
```

### 线性筛因数

```cpp
int d[maxn];
int num_d[maxn];
void get_d(int n)
{
    memset(prime,0,sizeof(prime));
    memset(vis,0,sizeof(vis));
    int cnt=0;
    d[1]=1;
    for(int i=2; i<=n; i++)
    {
        if(!vis[i])
        {
            prime[++cnt]=i;
            d[i]=2;
            num_d[i]=1;
        }
        for(int j=1; j<=cnt&&prime[j]*i<=n; j++)
        {
            vis[prime[j]*i]=1;
            if(i%prime[j]==0)
            {
                num_d[i*prime[j]]=num_d[i]+1;
                d[i*prime[j]]=d[i]/(num_d[i]+1)*(num_d[i]+2);
                break;
            }
            else
            {
                num_d[i*prime[j]]=1;
                d[i*prime[j]]=d[i]*2;
            }
        }
    }
}
```

### Miller Rabbin

```cpp
LL prime[6] = {2, 3, 5, 233, 331};           //这个地方不是随机的
LL qu(LL x, LL y, LL mod) {
    LL ret = 0;
    while(y) {
        if(y & 1)
            ret = (ret + x) % mod;
        x = x * 2 % mod;
        y >>= 1;
    }
    return ret;
}
LL qpow(LL a, LL n, LL mod) {
    LL ret = 1;
    while(n) {
        if(n & 1) ret = qu(ret, a, mod);
        a = qu(a, a, mod);
        n >>= 1;
    }
    return ret;
}
bool MR(LL p) {
    if(p < 2) return 0;
    if(p != 2 && p % 2 == 0) return 0;
    LL s = p - 1;
    while(! (s & 1)) s >>= 1;
    for(int i = 0; i < 5; ++i) {
        if(p == prime[i]) return 1;
        LL t = s, m = qpow(prime[i], s, p);
        while(t != p - 1 && m != 1 && m != p - 1) {
            m = qu(m, m, p);
            t <<= 1;
        }
        if(m != p - 1 && !(t & 1)) return 0;
    }
    return 1;
}
```

#### 素数测试

```cpp
const int S=20;
mt19937 rd(time(0));
ll mul2(ll a,ll b,ll p)
{
	ll res=0;
	while(b)
	{
		if(b&1) res=(res+a)%p;
		a=(a+a)%p;
		b>>=1;
	}
	return res;
}
ll pow2(ll a,ll b,ll p)
{
	ll res=1;
	while(b)
	{
		if(b&1) res=mul2(res,a,p);
		a=mul2(a,a,p);
		b>>=1;
	}
	return res;
}
int check(ll a,ll n,ll x,ll t)//一定是合数返回1,不一定返回0
{
	ll now,nex,i;
	now=nex=pow2(a,x,n);
	for(i=1;i<=t;i++)
	{
		now=mul2(now,now,n);
		if(now==1&&nex!=1&&nex!=n-1) return 1;
		nex=now;
	}
	if(now!=1) return 1;
	return 0;
}
int Miller_Rabin(ll n)
{
	if(n<2) return 0;
	if(n==2) return 1;
	if((n&1)==0) return 0;
	ll x,t,i;
	x=n-1;
	t=0;
	while((x&1)==0) x>>=1,t++;
	for(i=0;i<S;i++)
	{
		if(check(rd()%(n-1)+1,n,x,t)) return 0;
	}
	return 1;
}
ll Pollard_rho(ll x,ll c)
{
	ll i,k,g,t,y;
	i=1;
	k=2;
	y=t=rd()%x;
	while(1)
	{
		i++;
		t=(mul2(t,t,x)+c)%x;
		g=__gcd(y-t+x,x);
		if(g!=1&&g!=x) return g;
		if(y==t) return x;
		if(i==k)
		{
			y=t;
			k+=k;
		}
	}
}
vector<ll> fac;
void findfac(ll n)
{
	if(Miller_Rabin(n))
	{
		fac.pb(n);
		return;
	}
	ll t=n;
	while(t>=n) t=Pollard_rho(t,rd()%(n-1)+1);
	findfac(t);
	findfac(n/t);
}
void work(ll x)
{
	fac.clear();
	findfac(x);
}
```

## 线性基

```cpp
ll p[maxn];
ll a[maxn];
void get_linear_ji(ll n)            //线性基O(62*62*n)
{
    for(ll i=0;i<n;i++)
    {
        for(ll j=62;j>=0;j--)
        {
            if((a[i]>>j))
            {
               if(p[j])
               {
                   a[i]^=p[j];
               }
               else
               {
                   p[j]=a[i];
                   break;
               }
            }
        }
    }
    /* int r=0;
    for (int j=0;j<=62;j++) if (P[j]) r++;             //返回秩 线性基的个数
    return r; */
}
```

```cpp
struct Linear_Basis
{
    LL b[63],nb[63],tot;

    Linear_Basis()
    {
        tot=0;
        memset(b,0,sizeof(b));
        memset(nb,0,sizeof(nb));
    }
    void clear()
    {
        tot=0;
        memset(b,0,sizeof(b));
        memset(nb,0,sizeof(nb));
    }
    bool ins(LL x)                  //插入一个数
    {
        for(int i=62;i>=0;i--)
            if (x&(1LL<<i))
            {
                if (!b[i]) {b[i]=x;break;}
                x^=b[i];
            }
        return x>0;
    }

    LL Max(LL x)                  //求异或最大值
    {
        LL res=x;
        for(int i=62;i>=0;i--)
            res=max(res,res^b[i]);
        return res;
    }

    LL Min(LL x)                 //求异或最小值
    {
        LL res=x;
        for(int i=0;i<=62;i++)
            if (b[i]) res^=b[i];
        return res;
    }

    void rebuild()                //重构化为对角矩阵 为求Kth_MAX做铺垫
    {
        for(int i=62;i>=0;i--)
            for(int j=i-1;j>=0;j--)
                if (b[i]&(1LL<<j)) b[i]^=b[j];
        for(int i=0;i<=62;i++)
            if (b[i]) nb[tot++]=b[i];
    }

    LL Kth_Min(LL k)             //第K小   在调用之前必须rebuild
    {
    	rebuild();
        LL res=0;
        for(int i=62;i>=0;i--)
            if (k&(1LL<<i)) res^=nb[i];
        return res;
    }

} LB;

Linear_Basis merge(const Linear_Basis &n1,const Linear_Basis &n2)   //暴力合并两个线性基
{
    Linear_Basis ret=n1;
    for (int i=62; i>=0; i--)
        if (n2.b[i])
            ret.ins(n2.b[i]);
    return ret;
}
```

## FFT NTT FWT

### 普通FFT

```cpp
const ld pi=acos(-1);

struct Complex
{
    ld r,i;
    Complex(ld rr=0,ld ii=0):r(rr),i(ii){}
    friend Complex operator+(Complex a,Complex b){return Complex(a.r+b.r,a.i+b.i);}
    friend Complex operator-(Complex a,Complex b){return Complex(a.r-b.r,a.i-b.i);}
    friend Complex operator*(Complex a,Complex b){return Complex(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);}
};


void FFT(int n,Complex *c,int type)
{
    if(n==1)return;
    Complex a1[n>>1],a2[n>>1];
    for(int i=0;i<=n;i+=2)
    {
        a1[i>>1]=c[i];
        a2[i>>1]=c[i+1];
    }
    FFT(n>>1,a1,type);
    FFT(n>>1,a2,type);
    Complex Wn=Complex(cos(2.0*pi/n),type*sin(2.0*pi/n)),w=Complex(1,0);
    for(int i=0;i<(n>>1);i++,w=w*Wn)
    {
        c[i]=a1[i]+w*a2[i];
        c[i+(n>>1)]=a1[i]-w*a2[i];
    }
}
```

## Kuangbin FFT

```cpp
struct Complex
{
    double x,y;//实部和虚部 x+yi
    Complex(double _x = 0.0,double _y = 0.0){x = _x;y = _y;}
    Complex operator -(const Complex &b)const{return Complex(x-b.x,y-b.y);}
    Complex operator +(const Complex &b)const{return Complex(x+b.x,y+b.y);}
    Complex operator *(const Complex &b)const{return Complex(x*b.x-y*b.y,x*b.y+y*b.x);}
};
/*
* 进行FFT和IFFT前的反转变换。
* 位置i和 （i二进制反转后位置）互换
* len必须取2的幂
*/
void change(Complex y[],int len)
{
    int i,j,k;
    for(i = 1, j = len/2; i <len-1; i++)
    {
        if(i < j)swap(y[i],y[j]);
//交换互为小标反转的元素，i<j保证交换一次
//i做正常的+1，j左反转类型的+1,始终保持i和j是反转的
        k = len/2;
        while(j >= k)
        {
            j -= k;
            k /= 2;
        }
        if(j < k)j += k;
    }
}
/*
* 做FFT
* len必须为2^k形式，
* on==1时是DFT，on==-1时是IDFT
*/
void fft(Complex y[],int len,int on)
{
    change(y,len);
    for(int h = 2; h <= len; h <<= 1)
    {
        Complex wn(cos(-on*2*PI/h),sin(-on*2*PI/h));
        for(int j = 0; j < len; j+=h)
        {
            Complex w(1,0);
            for(int k = j; k < j+h/2; k++)
            {
                Complex u = y[k];
                Complex t = w*y[k+h/2];
                y[k] = u+t;
                y[k+h/2] = u-t;
                w = w*wn;
            }
        }
    }
    if(on == -1)
        for(int i = 0; i < len; i++)
            y[i].x /= len;
}
Complex x1[maxn],x2[maxn];
int Multiply(int *a,int len1,const int *b,int len2)   //这里的len1和len2为数组的长度
{                                                    //在传参的时候记得len+1
    int len = 1;
    while(len < len1*2 || len < len2*2)len<<=1;
    for(int i=0; i<len1; i++)
        x1[i]=Complex(a[i],0);
    for(int i=len1; i<len; i++)
        x1[i]=Complex(0,0);
    for(int i=0; i<len2; i++)
        x2[i]=Complex(b[i],0);
    for(int i=len2; i<len; i++)
        x2[i]=Complex(0,0);
    fft(x1,len,1);
    fft(x2,len,1);
    for(int i = 0; i < len; i++)
        x1[i] = x1[i]*x2[i];
    fft(x1,len,-1);
    for(int i = 0; i < len; i++)
        a[i] = (int)(x1[i].x+0.5);
    len=len1+len2-1;
    while(a[len] <= 0 && len > 0)len--;
    return len;         //返回的len为数组的最后一个数的下标，是数组的长度-1
}
int a1[maxn],a11[maxn],a2[maxn],a3[maxn];
```

### 非递归FFT

```cpp
namespace FFT
{
    struct Complex
    {
        double r,i;
        Complex(double real=0.0,double image=0.0)
        {
            r=real; i=image;
        }
        Complex operator + (const Complex o)
        {
            return Complex(r+o.r,i+o.i);
        }
        Complex operator - (const Complex o)
        {
            return Complex(r-o.r,i-o.i);
        }
        Complex operator * (const Complex o)
        {
            return Complex(r*o.r-i*o.i,r*o.i+i*o.r);
        }
    };

    void brc(Complex *y, int l)
    {
        register int i,j,k;
        for( i = 1, j = l / 2; i < l - 1; i++)
        {
            if (i < j) swap(y[i], y[j]);
            k = l / 2; while ( j >= k) j -= k,k /= 2;
            if (j < k) j += k;
        }
    }

    void FFT(Complex *y, int len, double on)
    {
        register int h, j, k;
        Complex u, t; brc(y, len);
        for(h = 2; h <= len; h <<= 1)
        {
            Complex wn(cos(on * 2 * PI / h), sin(on * 2 * PI / h));
            for(j = 0; j < len; j += h)
            {
                Complex w(1, 0);
                for(k = j; k < j + h / 2; k++)
                {
                    u = y[k]; t = w * y[k + h / 2];
                    y[k] = u + t; y[k + h / 2] = u - t;
                    w = w * wn;
                }
            }
        }
        if (on<0) for (int i = 0; i < len; i++) y[i].r/=len;
    }
}

FFT::Complex A[N],B[N],C[N],ans[N];
```

### Tourist FFT

```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define MAXN 100005
#define INF 1000000000
#define MOD 998244353
#define F first
#define S second
using namespace std;
typedef long long ll;
typedef pair<int,int> P;
int n,k;
const double PI=acos(-1.0);
//tourist
namespace fft
{
    struct num
    {
        double x,y;
        num() {x=y=0;}
        num(double x,double y):x(x),y(y){}
    };
    inline num operator+(num a,num b) {return num(a.x+b.x,a.y+b.y);}
    inline num operator-(num a,num b) {return num(a.x-b.x,a.y-b.y);}
    inline num operator*(num a,num b) {return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
    inline num conj(num a) {return num(a.x,-a.y);}

    int base=1;
    vector<num> roots={{0,0},{1,0}};
    vector<int> rev={0,1};
    const double PI=acosl(-1.0);

    void ensure_base(int nbase)
    {
        if(nbase<=base) return;
        rev.resize(1<<nbase);
        for(int i=0;i<(1<<nbase);i++)
            rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));
        roots.resize(1<<nbase);
        while(base<nbase)
        {
            double angle=2*PI/(1<<(base+1));
            for(int i=1<<(base-1);i<(1<<base);i++)
            {
                roots[i<<1]=roots[i];
                double angle_i=angle*(2*i+1-(1<<base));
                roots[(i<<1)+1]=num(cos(angle_i),sin(angle_i));
            }
            base++;
        }
    }

    void fft(vector<num> &a,int n=-1)
    {
        if(n==-1) n=a.size();
        assert((n&(n-1))==0);
        int zeros=__builtin_ctz(n);
        ensure_base(zeros);
        int shift=base-zeros;
        for(int i=0;i<n;i++)
            if(i<(rev[i]>>shift))
                swap(a[i],a[rev[i]>>shift]);
        for(int k=1;k<n;k<<=1)
        {
            for(int i=0;i<n;i+=2*k)
            {
                for(int j=0;j<k;j++)
                {
                    num z=a[i+j+k]*roots[j+k];
                    a[i+j+k]=a[i+j]-z;
                    a[i+j]=a[i+j]+z;
                }
            }
        }
    }

    vector<num> fa,fb;

    vector<int> multiply(vector<int> &a, vector<int> &b)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<sz;i++)
        {
            int x=(i<(int)a.size()?a[i]:0);
            int y=(i<(int)b.size()?b[i]:0);
            fa[i]=num(x,y);
        }
        fft(fa,sz);
        num r(0,-0.25/sz);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;
            if(i!=j) fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;
            fa[i]=z;
        }
        fft(fa,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++) res[i]=fa[i].x+0.5;
        return res;
    }

    vector<int> multiply_mod(vector<int> &a,vector<int> &b,int m,int eq=0)
    {
        int need=a.size()+b.size()-1;
        int nbase=0;
        while((1<<nbase)<need) nbase++;
        ensure_base(nbase);
        int sz=1<<nbase;
        if(sz>(int)fa.size()) fa.resize(sz);
        for(int i=0;i<(int)a.size();i++)
        {
            int x=(a[i]%m+m)%m;
            fa[i]=num(x&((1<<15)-1),x>>15);
        }
        fill(fa.begin()+a.size(),fa.begin()+sz,num{0,0});
        fft(fa,sz);
        if(sz>(int)fb.size()) fb.resize(sz);
        if(eq) copy(fa.begin(),fa.begin()+sz,fb.begin());
        else
        {
            for(int i=0;i<(int)b.size();i++)
            {
                int x=(b[i]%m+m)%m;
                fb[i]=num(x&((1<<15)-1),x>>15);
            }
            fill(fb.begin()+b.size(),fb.begin()+sz,num{0,0});
            fft(fb,sz);
        }
        double ratio=0.25/sz;
        num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);
        for(int i=0;i<=(sz>>1);i++)
        {
            int j=(sz-i)&(sz-1);
            num a1=(fa[i]+conj(fa[j]));
            num a2=(fa[i]-conj(fa[j]))*r2;
            num b1=(fb[i]+conj(fb[j]))*r3;
            num b2=(fb[i]-conj(fb[j]))*r4;
            if(i!=j)
            {
                num c1=(fa[j]+conj(fa[i]));
                num c2=(fa[j]-conj(fa[i]))*r2;
                num d1=(fb[j]+conj(fb[i]))*r3;
                num d2=(fb[j]-conj(fb[i]))*r4;
                fa[i]=c1*d1+c2*d2*r5;
                fb[i]=c1*d2+c2*d1;
            }
            fa[j]=a1*b1+a2*b2*r5;
            fb[j]=a1*b2+a2*b1;
        }
        fft(fa,sz);fft(fb,sz);
        vector<int> res(need);
        for(int i=0;i<need;i++)
        {
            ll aa=fa[i].x+0.5;
            ll bb=fb[i].x+0.5;
            ll cc=fa[i].y+0.5;
            res[i]=(aa+((bb%m)<<15)+((cc%m)<<30))%m;
        }
        return res;
    }
    vector<int> square_mod(vector<int> &a,int m)
    {
        return multiply_mod(a,a,m,1);
    }
};
vector<int> v;
int main()
{
    scanf("%d%d",&n,&k);
    v.resize(10,0);
    for(int i=0;i<k;i++)
    {
        int x;
        scanf("%d",&x);
        v[x]=1;
    }
    vector<int> ans;
    ans.push_back(1);
    int p=n/2;
    while(p)
    {
        if(p&1) ans=fft::multiply_mod(ans,v,MOD);
        v=fft::square_mod(v,MOD);
        p>>=1;
    }
    int res=0;
    for(auto t:ans) res=(res+1LL*t*t)%MOD;
    printf("%d\n",res);
    return 0;
}
```

### NTT

```cpp
#include<bits/stdc++.h>
#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)
#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)
#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)
#define ll long long
#define pp printf
#define hh pp("\n")
using namespace std;
  
const int mo = 998244353;
  
ll ksm(ll x, ll y) {
    ll s = 1;
    for(; y; y /= 2, x = x * x % mo)
        if(y & 1) s = s * x % mo;
    return s;
}
  
typedef vector<ll> V;
#define pb push_back
#define si size()
#define re resize
  
namespace ntt {
    const int nm = 1 << 18;
    ll a[nm], b[nm], w[nm]; int r[nm];
    void build() {
        for(int i = 1; i < nm; i *= 2) ff(j, 0, i)
            w[i + j] = ksm(3, (mo - 1) / 2 / i * j);
    }
    void dft(ll *a, int n, int f) {
        ff(i, 0, n) {
            r[i] = r[i / 2] / 2 + (i & 1) * (n / 2);
            if(i < r[i]) swap(a[i], a[r[i]]);
        } ll b;
        for(int i = 1; i < n; i *= 2) for(int j = 0; j < n; j += 2 * i)
            ff(k, 0, i) b = a[i + j + k] * w[i + k], a[i + j + k] = (a[j + k] - b) % mo, a[j + k] = (a[j + k] + b) % mo;
        if(f == -1) {
            reverse(a + 1, a + n);
            b = ksm(n, mo - 2);
            ff(i, 0, n) a[i] = (a[i] + mo) * b % mo;
        }
    }
    void fft(V &p, V &q) {
        int p0 = p.si + q.si - 1;
        int n = 1; while(n <= p0) n *= 2;
        ff(i, 0, n) a[i] = b[i] = 0;
        ff(i, 0, p.si) a[i] = p[i];
        ff(i, 0, q.si) b[i] = q[i];
        dft(a, n, 1); dft(b, n, 1);
        ff(i, 0, n) a[i] = a[i] * b[i] % mo;
        dft(a, n, -1);
        p.resize(p0);
        ff(i, 0, p0) p[i] = a[i];
    }
}
  
V operator * (V a, V b) {
    ntt :: fft(a, b);
    return a;
}
  
const int N = 2e5 + 5;
  
int n;
struct P {
    int x, y;
} a[N];
  
int cmp(P a, P b) { return a.x < b.x;}
  
  
ll fac[N], nf[N];
  
void build(int n) {
    fac[0] = 1;
    fo(i, 1, n) fac[i] = fac[i - 1]  * i % mo;
    nf[n] = ksm(fac[n], mo - 2);
    fd(i, n, 1) nf[i - 1] = nf[i] * (i) % mo;
}
  
ll C(int n, int m) {
    return fac[n] * nf[m] % mo * nf[n - m] % mo;
}
  
V dg(int x, int y) {
    if(x > y) {
        V b; b.re(1); b[0] = 1; return b;
    }
    if(x == y) {
        V b; b.re(a[x].x + 1);
        b[0] = ksm(2, a[x].y) - 1;
        ff(i, 1, b.si) b[i] = C(a[x].x, i);
        return b;
    }
    int m = x+y >>1;
    return dg(x, m) * dg(m + 1, y);
}
  
V b;
      
int main() {
//  freopen("a.in", "r", stdin);
    ntt :: build();
    build(2e5);
    scanf("%d", &n);
    fo(i, 1, n) scanf("%d", &a[i].x);
    fo(i, 1, n) scanf("%d", &a[i].y);
    b = dg(1, n);
    ff(i, 0, b.si) pp("%lld ", b[i]);
}
```

### Tourist NTT

```cpp
namespace ntt
{
struct num
{
    double x, y;
    num()
    {
        x = y = 0;
    }
    num(double x, double y) : x(x), y(y) {}
};
inline num operator+(num a, num b)
{
    return num(a.x + b.x, a.y + b.y);
}
inline num operator-(num a, num b)
{
    return num(a.x - b.x, a.y - b.y);
}
inline num operator*(num a, num b)
{
    return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}
inline num conj(num a)
{
    return num(a.x, -a.y);
}

int base = 1;
vector<num> roots = { { 0, 0 }, { 1, 0 } };
vector<int> rev = { 0, 1 };
const double PI = acosl(-1.0);

void ensure_base(int nbase)
{
    if (nbase <= base)
        return;
    rev.resize(1 << nbase);
    for (int i = 0; i < (1 << nbase); i++) rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));
    roots.resize(1 << nbase);
    while (base < nbase)
    {
        double angle = 2 * PI / (1 << (base + 1));
        for (int i = 1 << (base - 1); i < (1 << base); i++)
        {
            roots[i << 1] = roots[i];
            double angle_i = angle * (2 * i + 1 - (1 << base));
            roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));
        }
        base++;
    }
}

void fft(vector<num> &a, int n = -1)
{
    if (n == -1)
        n = a.size();
    assert((n & (n - 1)) == 0);
    int zeros = __builtin_ctz(n);
    ensure_base(zeros);
    int shift = base - zeros;
    for (int i = 0; i < n; i++)
        if (i < (rev[i] >> shift))
            swap(a[i], a[rev[i] >> shift]);
    for (int k = 1; k < n; k <<= 1)
    {
        for (int i = 0; i < n; i += 2 * k)
        {
            for (int j = 0; j < k; j++)
            {
                num z = a[i + j + k] * roots[j + k];
                a[i + j + k] = a[i + j] - z;
                a[i + j] = a[i + j] + z;
            }
        }
    }
}

vector<num> fa, fb;

vector<int> multiply(vector<int> &a, vector<int> &b)
{
    int need = a.size() + b.size() - 1;
    int nbase = 0;
    while ((1 << nbase) < need) nbase++;
    ensure_base(nbase);
    int sz = 1 << nbase;
    if (sz > (int)fa.size())
        fa.resize(sz);
    for (int i = 0; i < sz; i++)
    {
        int x = (i < (int)a.size() ? a[i] : 0);
        int y = (i < (int)b.size() ? b[i] : 0);
        fa[i] = num(x, y);
    }
    fft(fa, sz);
    num r(0, -0.25 / sz);
    for (int i = 0; i <= (sz >> 1); i++)
    {
        int j = (sz - i) & (sz - 1);
        num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;
        if (i != j)
            fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;
        fa[i] = z;
    }
    fft(fa, sz);
    vector<int> res(need);
    for (int i = 0; i < need; i++) res[i] = fa[i].x + 0.5;
    return res;
}

vector<int> multiply(vector<int> &a, vector<int> &b, int m, int eq = 0)
{
    int need = a.size() + b.size() - 1;
    int nbase = 0;
    while ((1 << nbase) < need) nbase++;
    ensure_base(nbase);
    int sz = 1 << nbase;
    if (sz > (int)fa.size())
        fa.resize(sz);
    for (int i = 0; i < (int)a.size(); i++)
    {
        int x = (a[i] % m + m) % m;
        fa[i] = num(x & ((1 << 15) - 1), x >> 15);
    }
    fill(fa.begin() + a.size(), fa.begin() + sz, num{ 0, 0 });
    fft(fa, sz);
    if (sz > (int)fb.size())
        fb.resize(sz);
    if (eq)
        copy(fa.begin(), fa.begin() + sz, fb.begin());
    else
    {
        for (int i = 0; i < (int)b.size(); i++)
        {
            int x = (b[i] % m + m) % m;
            fb[i] = num(x & ((1 << 15) - 1), x >> 15);
        }
        fill(fb.begin() + b.size(), fb.begin() + sz, num{ 0, 0 });
        fft(fb, sz);
    }
    double ratio = 0.25 / sz;
    num r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);
    for (int i = 0; i <= (sz >> 1); i++)
    {
        int j = (sz - i) & (sz - 1);
        num a1 = (fa[i] + conj(fa[j]));
        num a2 = (fa[i] - conj(fa[j])) * r2;
        num b1 = (fb[i] + conj(fb[j])) * r3;
        num b2 = (fb[i] - conj(fb[j])) * r4;
        if (i != j)
        {
            num c1 = (fa[j] + conj(fa[i]));
            num c2 = (fa[j] - conj(fa[i])) * r2;
            num d1 = (fb[j] + conj(fb[i])) * r3;
            num d2 = (fb[j] - conj(fb[i])) * r4;
            fa[i] = c1 * d1 + c2 * d2 * r5;
            fb[i] = c1 * d2 + c2 * d1;
        }
        fa[j] = a1 * b1 + a2 * b2 * r5;
        fb[j] = a1 * b2 + a2 * b1;
    }
    fft(fa, sz);
    fft(fb, sz);
    vector<int> res(need);
    for (int i = 0; i < need; i++)
    {
        ll aa = fa[i].x + 0.5;
        ll bb = fb[i].x + 0.5;
        ll cc = fa[i].y + 0.5;
        res[i] = (aa + ((bb % m) << 15) + ((cc % m) << 30)) % m;
    }
    return res;
}
vector<int> square(vector<int> &a, int m)
{
    return multiply(a, a, m, 1);
}
};
```

### FWT

#### yyb

```cpp
void FWT_or(int *a,int opt)
{
    for(int i=1; i<N; i<<=1)
        for(int p=i<<1,j=0; j<N; j+=p)
            for(int k=0; k<i; ++k)
                if(opt==1)a[i+j+k]=(a[j+k]+a[i+j+k])%MOD;
                else a[i+j+k]=(a[i+j+k]+MOD-a[j+k])%MOD;
}
void FWT_and(int *a,int opt)
{
    for(int i=1; i<N; i<<=1)
        for(int p=i<<1,j=0; j<N; j+=p)
            for(int k=0; k<i; ++k)
                if(opt==1)a[j+k]=(a[j+k]+a[i+j+k])%MOD;
                else a[j+k]=(a[j+k]+MOD-a[i+j+k])%MOD;
}
void FWT_xor(int *a,int opt)
{
    for(int i=1; i<N; i<<=1)
        for(int p=i<<1,j=0; j<N; j+=p)
            for(int k=0; k<i; ++k)
            {
                int X=a[j+k],Y=a[i+j+k];
                a[j+k]=(X+Y)%MOD;
                a[i+j+k]=(X+MOD-Y)%MOD;
                if(opt==-1)a[j+k]=1ll*a[j+k]*inv2%MOD,a[i+j+k]=1ll*a[i+j+k]*inv2%MOD;
            }
}
```

#### sjf

```cpp
namespace FWT
{
	ll inv2;//2对p的逆元 仅在xor FWT逆变换用到
	const ll p=1e9+7;          //若不需取模时请注意把逆元替换掉
	ll pow2(ll a,ll b)
	{
		ll res=1;
		while(b)
		{
			if(b&1) res=res*a%p;
			a=a*a%p;
			b>>=1;
		}
		return res;
	}
    //对a数组进行FWT变换 n必须为2^m形式
    //若f==1是xor_FWT,若f==2是and_FWT,若f==3是or_FWT
    //v=0时是正向FWT变换，v=1时是逆变换
	void fwt(ll *a,int n,int f,int v)
	{  
		for(int d=1;d<n;d<<=1)
		{
			for(int m=d<<1,i=0;i<n;i+=m)
			{
				for(int j=0;j<d;j++)
				{  
					ll x=a[i+j],y=a[i+j+d];
					if(!v)
					{
						if(f==1) a[i+j]=(x+y)%p,a[i+j+d]=(x-y+p)%p;//xor
						else if(f==2) a[i+j]=(x+y)%p;//and
						else if(f==3) a[i+j+d]=(x+y)%p;//or
					}
					else
					{
						if(f==1) a[i+j]=(x+y)*inv2%p,a[i+j+d]=(x-y+p)%p*inv2%p;//xor
						else if(f==2) a[i+j]=(x-y+p)%p;//and
						else if(f==3) a[i+j+d]=(y-x+p)%p;//or
					}
				}
			}
		}
	}
	
	//结果存在a 
	void XOR(ll *a,ll *b,int n)
	{
		int len;
		for(len=1;len<=n;len<<=1);
		fwt(a,len,1,0);
		fwt(b,len,1,0);
		for(int i=0;i<len;i++) a[i]=a[i]*b[i]%p;
		inv2=pow2(2,p-2);
		fwt(a,len,1,1);
	}
	void AND(ll *a,ll *b,int n)
	{
		int len;
		for(len=1;len<=n;len<<=1);
		fwt(a,len,2,0);
		fwt(b,len,2,0);
		for(int i=0;i<len;i++) a[i]=a[i]*b[i]%p;
		fwt(a,len,2,1);
	}
	void OR(ll *a,ll *b,int n)
	{
		int len;
		for(len=1;len<=n;len<<=1);
		fwt(a,len,3,0);
		fwt(b,len,3,0);
		for(int i=0;i<len;i++) a[i]=a[i]*b[i]%p;
		fwt(a,len,3,1);
	}
};
```

## 拉格朗日插值

### 求多项式$f$的前缀和$f(0)+f(1)+···+f(n)$的值
### $F(0)=0$,$F(1)=f(0)$,$F(2)=f(0)+f(1)$,···,$F(n)=f(0)+f(1)+···+f(n-1)$
### 只需要把多项式的前缀和作为点的值插值

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define O 1ll
using namespace std;
const int N=2005,mod=998244353;
int n,k,x[N],y[N],num[N],tmp[N],res[N],inv[N];
void Add(int &x,int y)
{
    x+=y;
    if(x>=mod) x-=mod;
}
void exGCD(int a,int b,int &x,int &y)
{
    if(!b) x=1,y=0;
    else exGCD(b,a%b,y,x),y-=a/b*x;
}
int Inv(int x)
{
    int xx,yy;
    exGCD(x,mod,xx,yy);
    Add(xx,mod);
    return xx;
}
void Lagrange()
{
    for(int i=1; i<=n; i++)
    {
        int den=1,lst=0;
        for(int j=1; j<=n; j++)
            if(i!=j) den=O*den*(x[i]-x[j]+mod)%mod;
        den=O*y[i]*Inv(den)%mod;
        for(int j=0; j<n; j++)
        {
            tmp[j]=O*(num[j]-lst+mod)*inv[i]%mod;
            Add(res[j],O*den*tmp[j]%mod),lst=tmp[j];
        }
    }
}
void Pre()
{
    num[0]=1;
    for(int i=1; i<=n; swap(num,tmp),i++)
    {
        tmp[0]=0;
        inv[i]=Inv(mod-x[i]);
        for(int j=1; j<=i; j++) tmp[j]=num[j-1];
        for(int j=0; j<=i; j++) Add(tmp[j],O*num[j]*(mod-x[i])%mod);
    }
}
int Calc(int x)
{
    int ret=0,var=1;
    for(int i=0; i<n; var=O*var*x%mod,i++)
        Add(ret,O*var*res[i]%mod);
    return ret;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1; i<=n; i++) //输入你要插值的n个点（n-1次多项式）
        scanf("%d%d",&x[i],&y[i]);
    Pre();                   //预处理
    Lagrange();
    printf("%d",Calc(k));       //输出多项式在k处的值
    return 0;
}
```

```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define ll long long
#define ull unsigned long long
#define fi first
#define se second
#define mp make_pair
#define pii pair<int,int>
#define ull unsigned long long
#define all(x) x.begin(),x.end()
#pragma GCC optimize("unroll-loops")
#define inline inline __attribute__(  \
(always_inline, __gnu_inline__, __artificial__)) \
__attribute__((optimize("Ofast"))) __attribute__((target("sse"))) \
__attribute__((target("sse2"))) __attribute__((target("mmx")))
#define IO ios::sync_with_stdio(false);
#define rep(ii,a,b) for(int ii=a;ii<=b;++ii)
#define per(ii,a,b) for(int ii=b;ii>=a;--ii)
#define for_node(x,i) for(int i=head[x];i;i=e[i].next)
#define show(x) cout<<#x<<"="<<x<<endl
#define showa(a,b) cout<<#a<<'['<<b<<"]="baidu<a[b]<<endl
#define show2(x,y) cout<<#x<<"="<<x<<" "<<#y<<"="<<y<<endl
#define show3(x,y,z) cout<<#x<<"="<<x<<" "<<#y<<"="<<y<<" "<<#z<<"="<<z<<endl
#define show4(w,x,y,z) cout<<#w<<"="<<w<<" "<<#x<<"="<<x<<" "<<#y<<"="<<y<<" "<<#z<<"="<<z<<endl
using namespace std;
const int maxn=1e6+10,maxm=2e6+10;
const int INF=0x3f3f3f3f;
const ll mod=1e9+7;
const double PI=acos(-1.0);
//head
int casn,n,m,k;
int num[maxn];
ll a[maxn];
ll pow_mod(ll a,ll b,ll c=mod,ll ans=1){while(b){if(b&1) ans=(a*ans)%c;a=(a*a)%c,b>>=1;}return ans;}

namespace polysum {
    const int maxn=101000;
    const ll mod=1e9+7;
    ll a[maxn],f[maxn],g[maxn],p[maxn],p1[maxn],p2[maxn],b[maxn],h[maxn][2],C[maxn];
    ll calcn(int d,ll *a,ll n) {//d次多项式(a[0-d])求第n项            求f(n)
        if (n<=d) return a[n];
        p1[0]=p2[0]=1;
        rep(i,0,d) {
            ll t=(n-i+mod)%mod;
            p1[i+1]=p1[i]*t%mod;
        }
        rep(i,0,d) {
            ll t=(n-d+i+mod)%mod;
            p2[i+1]=p2[i]*t%mod;
        }
        ll ans=0;
        rep(i,0,d) {
            ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod;
            if ((d-i)&1) ans=(ans-t+mod)%mod;
            else ans=(ans+t)%mod;
        }
        return ans;
    }
    void init(int maxm) {//初始化预处理阶乘和逆元(取模乘法)
        f[0]=f[1]=g[0]=g[1]=1;
        rep(i,2,maxm+4) f[i]=f[i-1]*i%mod;
        g[maxm+4]=pow_mod(f[maxm+4],mod-2);
        per(i,1,maxm+3) g[i]=g[i+1]*(i+1)%mod;
    }
    ll polysum(ll n,ll *a,ll m) { // a[0].. a[m] \sum_{i=0}^{n-1} a[i]
        // m次多项式求第n项前缀和
        a[m+1]=calcn(m,a,m+1);                          //不包括n
        rep(i,1,m+1) a[i]=(a[i-1]+a[i])%mod;
        return calcn(m+1,a,n-1);
    }
    ll qpolysum(ll R,ll n,ll *a,ll m) { // a[0].. a[m] \sum_{i=0}^{n-1} a[i]*R^i
        if (R==1) return polysum(n,a,m);
        a[m+1]=calcn(m,a,m+1);
        ll r=pow_mod(R,mod-2),p3=0,p4=0,c,ans;
        h[0][0]=0;
        h[0][1]=1;
        rep(i,1,m+1) {
            h[i][0]=(h[i-1][0]+a[i-1])*r%mod;
            h[i][1]=h[i-1][1]*r%mod;
        }
        rep(i,0,m+1) {
            ll t=g[i]*g[m+1-i]%mod;
            if (i&1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod;
            else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod;
        }
        c=pow_mod(p4,mod-2)*(mod-p3)%mod;
        rep(i,0,m+1) h[i][0]=(h[i][0]+h[i][1]*c)%mod;
        rep(i,0,m+1) C[i]=h[i][0];
        ans=(calcn(m,C,n)*pow_mod(R,n)-c)%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
}


int main() {
//#define test
#ifdef test
    auto _start = chrono::high_resolution_clock::now();
    freopen("in.txt","r",stdin);freopen("out.txt","w",stdout);
#endif
    IO;
    ll n,r,k;
    cin>>n>>r>>k;
    polysum::init(k+5);
    rep(i,0,2010) a[i]=pow_mod(i,k);
    ll ans=polysum::qpolysum(r,n+1,a,k+1);
    if(k==0) ans=(ans-1+mod)%mod;
    cout<<ans<<endl;
#ifdef test
    auto _end = chrono::high_resolution_clock::now();
  cerr << "elapsed time: " << chrono::duration<double, milli>(_end - _start).count() << " ms\n";
    fclose(stdin);fclose(stdout);system("out.txt");
#endif
    return 0;
}
```

## 递推式

### 一维线性

```cpp
#include <bits/stdc++.h>

using namespace std;
#define rep(i,a,n) for (long long i=a;i<n;i++)
#define per(i,a,n) for (long long i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((long long)(x).size())
typedef vector<long long> VI;
typedef long long ll;
typedef pair<long long,long long> PII;
const ll mod=1e9+7;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head

long long _,n;
namespace linear_seq
{
    const long long N=10010;
    ll res[N],base[N],_c[N],_md[N];

    vector<long long> Md;
    void mul(ll *a,ll *b,long long k)
    {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k)
            _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (long long i=k+k-1;i>=k;i--) if (_c[i])
            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    long long solve(ll n,VI a,VI b)
    { // a 系数 b 初值 b[n+1]=a[0]*b[n]+...
//        printf("%d\n",SZ(b));
        ll ans=0,pnt=0;
        long long k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (long long p=pnt;p>=0;p--)
        {
            mul(res,res,k);
            if ((n>>p)&1)
            {
                for (long long i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s)
    {
        VI C(1,1),B(1,1);
        long long L=0,m=1,b=1;
        rep(n,0,SZ(s))
        {
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if (d==0) ++m;
            else if (2*L<=n)
            {
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            }
            else
            {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    long long gao(VI a,ll n)
    {
        VI c=BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};

int main()
{
    while(~scanf("%I64d", &n))
    {
    	printf("%I64d\n",linear_seq::gao(VI{1,5,11,36,95,281,781,2245,6336,18061, 51205},n-1));
    }
}
```

#### CSL

```cpp
#include <bits/stdc++.h>
using namespace std;
#ifndef ONLINE_JUDGE
#define debug(fmt, ...) fprintf(stderr, "[%s] " fmt "\n", __func__, ##__VA_ARGS__)
#else
#define debug(...)
#endif
 
// given first m items init[0..m-1] and coefficents trans[0..m-1] or
// given first 2 *m items init[0..2m-1], it will compute trans[0..m-1]
// for you. trans[0..m] should be given as that
//      init[m] = sum_{i=0}^{m-1} init[i] * trans[i]
struct LinearRecurrence
{
    using int64 = long long;
    using vec = std::vector<int64>;
 
    static void extand(vec& a, size_t d, int64 value = 0)
    {
        if (d <= a.size()) return;
        a.resize(d, value);
    }
    static vec BerlekampMassey(const vec& s, int64 mod)
    {
        std::function<int64(int64)> inverse = [&](int64 a) {
            return a == 1 ? 1 : (int64)(mod - mod / a) * inverse(mod % a) % mod;
        };
        vec A = {1}, B = {1};
        int64 b = s[0];
        for (size_t i = 1, m = 1; i < s.size(); ++i, m++)
        {
            int64 d = 0;
            for (size_t j = 0; j < A.size(); ++j)
            {
                d += A[j] * s[i - j] % mod;
            }
            if (!(d %= mod)) continue;
            if (2 * (A.size() - 1) <= i)
            {
                auto temp = A;
                extand(A, B.size() + m);
                int64 coef = d * inverse(b) % mod;
                for (size_t j = 0; j < B.size(); ++j)
                {
                    A[j + m] -= coef * B[j] % mod;
                    if (A[j + m] < 0) A[j + m] += mod;
                }
                B = temp, b = d, m = 0;
            }
            else
            {
                extand(A, B.size() + m);
                int64 coef = d * inverse(b) % mod;
                for (size_t j = 0; j < B.size(); ++j)
                {
                    A[j + m] -= coef * B[j] % mod;
                    if (A[j + m] < 0) A[j + m] += mod;
                }
            }
        }
        return A;
    }
    static void exgcd(int64 a, int64 b, int64& g, int64& x, int64& y)
    {
        if (!b)
            x = 1, y = 0, g = a;
        else
        {
            exgcd(b, a % b, g, y, x);
            y -= x * (a / b);
        }
    }
    static int64 crt(const vec& c, const vec& m)
    {
        int n = c.size();
        int64 M = 1, ans = 0;
        for (int i = 0; i < n; ++i) M *= m[i];
        for (int i = 0; i < n; ++i)
        {
            int64 x, y, g, tm = M / m[i];
            exgcd(tm, m[i], g, x, y);
            ans = (ans + tm * x * c[i] % M) % M;
        }
        return (ans + M) % M;
    }
    static vec ReedsSloane(const vec& s, int64 mod)
    {
        auto inverse = [](int64 a, int64 m) {
            int64 d, x, y;
            exgcd(a, m, d, x, y);
            return d == 1 ? (x % m + m) % m : -1;
        };
        auto L = [](const vec& a, const vec& b) {
            int da = (a.size() > 1 || (a.size() == 1 && a[0])) ? a.size() - 1 : -1000;
            int db = (b.size() > 1 || (b.size() == 1 && b[0])) ? b.size() - 1 : -1000;
            return std::max(da, db + 1);
        };
        auto prime_power = [&](const vec& s, int64 mod, int64 p, int64 e) {
            // linear feedback shift register mod p^e, p is prime
            std::vector<vec> a(e), b(e), an(e), bn(e), ao(e), bo(e);
            vec t(e), u(e), r(e), to(e, 1), uo(e), pw(e + 1);
            ;
            pw[0] = 1;
            for (int i = pw[0] = 1; i <= e; ++i) pw[i] = pw[i - 1] * p;
            for (int64 i = 0; i < e; ++i)
            {
                a[i] = {pw[i]}, an[i] = {pw[i]};
                b[i] = {0}, bn[i] = {s[0] * pw[i] % mod};
                t[i] = s[0] * pw[i] % mod;
                if (t[i] == 0)
                {
                    t[i] = 1, u[i] = e;
                }
                else
                {
                    for (u[i] = 0; t[i] % p == 0; t[i] /= p, ++u[i])
                        ;
                }
            }
            for (size_t k = 1; k < s.size(); ++k)
            {
                for (int g = 0; g < e; ++g)
                {
                    if (L(an[g], bn[g]) > L(a[g], b[g]))
                    {
                        ao[g] = a[e - 1 - u[g]];
                        bo[g] = b[e - 1 - u[g]];
                        to[g] = t[e - 1 - u[g]];
                        uo[g] = u[e - 1 - u[g]];
                        r[g] = k - 1;
                    }
                }
                a = an, b = bn;
                for (int o = 0; o < e; ++o)
                {
                    int64 d = 0;
                    for (size_t i = 0; i < a[o].size() && i <= k; ++i)
                    {
                        d = (d + a[o][i] * s[k - i]) % mod;
                    }
                    if (d == 0)
                    {
                        t[o] = 1, u[o] = e;
                    }
                    else
                    {
                        for (u[o] = 0, t[o] = d; t[o] % p == 0; t[o] /= p, ++u[o])
                            ;
                        int g = e - 1 - u[o];
                        if (L(a[g], b[g]) == 0)
                        {
                            extand(bn[o], k + 1);
                            bn[o][k] = (bn[o][k] + d) % mod;
                        }
                        else
                        {
                            int64 coef = t[o] * inverse(to[g], mod) % mod * pw[u[o] - uo[g]] % mod;
                            int m = k - r[g];
                            extand(an[o], ao[g].size() + m);
                            extand(bn[o], bo[g].size() + m);
                            for (size_t i = 0; i < ao[g].size(); ++i)
                            {
                                an[o][i + m] -= coef * ao[g][i] % mod;
                                if (an[o][i + m] < 0) an[o][i + m] += mod;
                            }
                            while (an[o].size() && an[o].back() == 0) an[o].pop_back();
                            for (size_t i = 0; i < bo[g].size(); ++i)
                            {
                                bn[o][i + m] -= coef * bo[g][i] % mod;
                                if (bn[o][i + m] < 0) bn[o][i + m] -= mod;
                            }
                            while (bn[o].size() && bn[o].back() == 0) bn[o].pop_back();
                        }
                    }
                }
            }
            return std::make_pair(an[0], bn[0]);
        };
 
        std::vector<std::tuple<int64, int64, int>> fac;
        for (int64 i = 2; i * i <= mod; ++i)
        {
            if (mod % i == 0)
            {
                int64 cnt = 0, pw = 1;
                while (mod % i == 0) mod /= i, ++cnt, pw *= i;
                fac.emplace_back(pw, i, cnt);
            }
        }
        if (mod > 1) fac.emplace_back(mod, mod, 1);
        std::vector<vec> as;
        size_t n = 0;
        for (auto&& x : fac)
        {
            int64 mod, p, e;
            vec a, b;
            std::tie(mod, p, e) = x;
            auto ss = s;
            for (auto&& x : ss) x %= mod;
            std::tie(a, b) = prime_power(ss, mod, p, e);
            as.emplace_back(a);
            n = std::max(n, a.size());
        }
        vec a(n), c(as.size()), m(as.size());
        for (size_t i = 0; i < n; ++i)
        {
            for (size_t j = 0; j < as.size(); ++j)
            {
                m[j] = std::get<0>(fac[j]);
                c[j] = i < as[j].size() ? as[j][i] : 0;
            }
            a[i] = crt(c, m);
        }
        return a;
    }
 
    LinearRecurrence(const vec& s, const vec& c, int64 mod) : init(s), trans(c), mod(mod), m(s.size()) {}
    LinearRecurrence(const vec& s, int64 mod, bool is_prime = true) : mod(mod)
    {
        vec A;
        if (is_prime)
            A = BerlekampMassey(s, mod);
        else
            A = ReedsSloane(s, mod);
        if (A.empty()) A = {0};
        m = A.size() - 1;
        trans.resize(m);
        for (int i = 0; i < m; ++i)
        {
            trans[i] = (mod - A[i + 1]) % mod;
        }
        std::reverse(trans.begin(), trans.end());
        init = {s.begin(), s.begin() + m};
    }
    int64 calc(int64 n)
    {
        if (mod == 1) return 0;
        if (n < m) return init[n];
        vec v(m), u(m << 1);
        int msk = !!n;
        for (int64 m = n; m > 1; m >>= 1) msk <<= 1;
        v[0] = 1 % mod;
        for (int x = 0; msk; msk >>= 1, x <<= 1)
        {
            std::fill_n(u.begin(), m * 2, 0);
            x |= !!(n & msk);
            if (x < m)
                u[x] = 1 % mod;
            else
            { // can be optimized by fft/ntt
                for (int i = 0; i < m; ++i)
                {
                    for (int j = 0, t = i + (x & 1); j < m; ++j, ++t)
                    {
                        u[t] = (u[t] + v[i] * v[j]) % mod;
                    }
                }
                for (int i = m * 2 - 1; i >= m; --i)
                {
                    for (int j = 0, t = i - m; j < m; ++j, ++t)
                    {
                        u[t] = (u[t] + trans[j] * u[i]) % mod;
                    }
                }
            }
            v = {u.begin(), u.begin() + m};
        }
        int64 ret = 0;
        for (int i = 0; i < m; ++i)
        {
            ret = (ret + v[i] * init[i]) % mod;
        }
        return ret;
    }
 
    vec init, trans;
    int64 mod;
    int m;
};
 
const int mod = 1e9;
 
typedef long long ll;
 
ll Pow(ll a, ll n, ll mod)
{
    ll t = 1;
    for (; n; n >>= 1, (a *= a) %= mod)
        if (n & 1) (t *= a) %= mod;
    return t;
}
 
int main()
{
    int n, m;
    cin >> n >> m;
    std::vector<long long> f = {0, 1};
    for (int i = 2; i < m * 2 + 5; i++)
        f.push_back((f[i - 1] + f[i - 2]) % mod);
 
    for (auto& t : f) t = Pow(t, m, mod);
    for (int i = 1; i < m * 2 + 5; i++)
        f[i] = (f[i - 1] + f[i]) % mod;
    LinearRecurrence solver(f, mod, false);
    printf("%lld\n", solver.calc(n));
}
```

## 中国剩余定理

```cpp
int exgcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    int r=exgcd(b,a%b,x,y);
    int tmp=x;
    x=y;
    y=(tmp-(a/b)*y);
    return r;
}
int crt(int *a,int *m,int n)
{
    int M=1,ans=0;
    for(int i=1;i<=n;i++)
        M*=m[i];
    int x,y;
    for(int i=1;i<=n;i++)
    {
        int nowm=(M/m[i]);
        int remain=exgcd(nowm,m[i],x,y);
        ans=(ans+a[i]*nowm*x)%M;
    }
    return ans;
}
```

前置模板:扩展欧几里得
```cpp
ll M[maxn];
ll C[maxn];
void exCRT()
{
    int n;
    scanf("%d",&n);
    for (LL i = 1; i <= n; i++)
        scanf("%lld%lld", &M[i], &C[i]);
    bool flag = 1;
    for (ll i = 2; i <= n; i++)
    {
        ll M1 = M[i - 1], M2 = M[i], C2 = C[i], C1 = C[i - 1], T = gcd(M1, M2);
        if ((C2 - C1) % T != 0)
        {
            flag = 0;
            break;
        }
        M[i] = (M1 * M2) / T;
        C[i] = ( inv( M1 / T, M2 / T ) * (C2 - C1) / T ) % (M2 / T) * M1 + C1;
        C[i] = (C[i] % M[i] + M[i]) % M[i];
    }
    printf("%lld\n", flag ? C[n] : -1);
}
```

## 高斯消元

```cpp
double a[N][N];
int Gauss(int n,int m){
    int col,i,mxr,j,row;
    for(row=col=1;row<=n&&col<=m;row++,col++){
        mxr = row;
        for(i=row+1;i<=n;i++)
            if(fabs(a[i][col])>fabs(a[mxr][col]))
                mxr = i;
        if(mxr != row) swap(a[row],a[mxr]);
        if(fabs(a[row][col]) < eps){
            row--;
            continue;
        }
        for(i=1;i<=n;i++)///消成上三角矩阵
            if(i!=row&&fabs(a[i][col])>eps)
                for(j=m;j>=col;j--)
                    a[i][j]-=a[row][j]/a[row][col]*a[i][col];
    }
    row--;
    for(int i = row;i>=1;i--){///回代成对角矩阵
        for(int j = i + 1;j <= row;j++){
                a[i][m] -= a[j][m] * a[i][j];
        }
        a[i][m] /= a[i][i];
    }
    return row;          //返回秩
}
```

## 博弈

+ Nim 游戏：每轮从若干堆石子中的一堆取走若干颗。先手必胜条件为石子数量异或和非零。
+ 阶梯 Nim 游戏：可以选择阶梯上某一堆中的若干颗向下推动一级，直到全部推下去。先手必胜条件是奇数阶梯的异或和非零（对于偶数阶梯的操作可以模仿）。
+ Anti-SG：无法操作者胜。先手必胜的条件是：
  + SG 不为 0 且某个单一游戏的 SG 大于 1 。
  + SG 为 0 且没有单一游戏的 SG 大于 1。
+ Every-SG：对所有单一游戏都要操作。先手必胜的条件是单一游戏中的最大 step 为奇数。
  + 对于终止状态 step 为 0
  + 对于 SG 为 0 的状态，step 是最大后继 step +1
  + 对于 SG 非 0 的状态，step 是最小后继 step +1
+ 树上删边：叶子 SG 为 0，非叶子结点为所有子结点的 SG 值加 1 后的异或和。

尝试：

+ 打表找规律
+ 寻找一类必胜态（如对称局面）
+ 直接博弈 dp
